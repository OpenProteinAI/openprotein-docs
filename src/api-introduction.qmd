---
title: Introduction
---

Here's a quick overview of our jobs system, and steps to access auth credentials for our APIs. You'll find more exhaustive details on our endpoints at [Project](./api-project.qmd) and [PoET](./api-poet.qmd), serving our core and generative workflows respectively.

## Navigating the Job System

Our endpoints follow an asynchronous POST and GET framework. Once you initiate a task via our POST endpoints, the system schedules the job. This means that even for tasks that may take a while to complete, your request will return immediately.

The POST response will contain a job ID (`job_id`) in its response json. This job ID is a unique identifier that allows you to track your job. You can use this same job ID with our GET endpoints to monitor the progress of your task. Please note that only you can access your jobs, a different user cannot access your jobs even with your specific job ID.

Whilst your job is underway, the API will indicate the status as `PENDING`. Once the job has concluded (`SUCCESS`), you can retrieve your results by invoking the same endpoint using your job ID in the payload (see specific endpoint details for more guidance). The `/api/v1/jobs/JOB_ID` endpoint is at your disposal to check the status of a job before obtaining all the results.

This design ensures that long-running tasks don't keep you waiting, and ensures you can always get the results of a job back at a later date.

Remember, your job ID is both unique and crucial for fetching the results of your task. So, ensure to keep a note of it when you initiate a task.

## Login

### Steps to Log in

#### On this page
You can log in directly on this page using the Authorize</span> button. This action will let you browse the API documentation and execute test queries directly in your browser.

#### Within your IDE
For programmatic authorization, retrieve an access token through our /login</span> endpoint, then include this in the header of your subsequent requests to authorize access. A Python example using the Requests library is provided below:


```python
  import requests

  # Get the access token using your login credentials:
  r = requests.post("https://openprotein.ai/api/v1/login/user-access-token", data={"username": your_username, "password": your_password})
  assert r.status_code==200

  # Build the authorization header for subsequent requests
  auth_header = {'Authorization': '{} {}'.format(r.json()['token_type'], r.json()['access_token'])}

  # Make authorized requests to our endpoints, for instance:
  example_request = requests.get("https://openprotein.ai/api/v1/jobs", headers=auth_header)
  print(f"Example request has status {example_request.status_code}")
```
For easier usage, consider using session management:

```python
with requests.Session() as sess:
    sess.headers.update(auth_header)
example_request = requests.get("https://openprotein.ai/api/v1/jobs")
print(f"Example request has status {example_request.status_code}")
```

## Jobs
Endpoints to track job status for asynchronous jobs.
Use these to verify the status (PENDING, RUNNING, SUCCESS) of your jobs and view basic metadata (e.g., job creation date).
Here is a simple example where we submit an MSA (multiple sequence alignment) request and then fetch the result:

```python
# Example of jobs 
seed_sequence  = "MALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAEDLQVGQVELGGGPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN" # Human INS sequence
example_request = requests.post("https://openprotein.ai/api/v1/poet/align/msa", files={"msa_file":seed_sequence.encode()}, headers=auth_header)
job_id = example_request.json()['job_id']
print(f"Example request has status {example_request.status_code} and jobid {job_id}")

# will be PENDING and then SUCCESS
response = requests.get("http://openprotein.ai/api/v1/poet/align/msa", params={"job_id":job_id}, headers=auth_header)
print("status", response.headers['job_status'])
print("Generated MSA: ", response.text)
```

## Endpoints

```{=html}
  <script src="https://unpkg.com/swagger-ui-dist@5.1/swagger-ui-bundle.js"></script>
  <script>
    window.onload = function() {
      const ui = SwaggerUIBundle({
        url: "https://dev.api.openprotein.ai/openapi.json",
        dom_id: "#swagger-ui",
        config: {
          deepLinking: true,
          tagsSorter: "alpha",
          docExpansion: "list",
        },
        requestInterceptor: (request) => {
          const requestPath = request.url.split('/').slice(3).join('/')
          if (!request.url.includes("openapi.json")) {
            // Modify the request URL for other endpoints
            request.url = "https://dev.api.openprotein.ai/" + requestPath
          } 
          return request;
        },
      });
    };
  </script>

  <script type="module">
    import addSwaggerEndpointsToTOC from './utils/addSwaggerEndpointsToTOC.js';

    addSwaggerEndpointsToTOC(4);
  </script>
  <link rel="stylesheet" href="css/swagger-ui.css">
  <div id="swagger-ui"></div>
   
```
## Getting started 

```{=html}
  <table class="table table-bordered">
    <!-- <caption>As described in the section above, Quarto tables are great.</caption> -->
    <thead>
      <tr>
        <th scope="col">Sections</th>
        <th scope="col">Description</th>
        <th scope="col">Endpoints</th>
      </tr>
    </thead>
    <tbody>
      <tr scope="row">
        <td class="p-3"><a href="./api-project.qmd">Projects</a></td>
        <td class="p-3">This section includes endpoints for tasks under ‘Projects’ which allows users to analyze datasets, training sequence-to-function prediction models, using those models to predict properties for new sequences, and designing optimized libraries of sequence variants.</td>
        <td class="pe-5 pt-3">
          <ul>
            <li>Assaydata</li>
            <li>Train</li>
            <li>Predict</li>
            <li>Design</li>
            <li>Jobs</li>
            <li>Embeddings</li>
          </ul>
      </tr>
      <tr scope="row">
        <td class="p-3"><a href="./api-poet.qmd">PoET</a></td>
        <td class="p-3">This section includes the endpoints for tasks under ‘PoET’ where users can design protein sequences de novo, without functional measurements of the protein of interest. Here, users can generate single substitution, combinatorial variant libraries, or a bespoke high-diversity library.</td>
        <td class="pe-5 pt-3">
          <ul>
            <li>Align</li>
            <li>PoET</li>
          </ul>
      </tr>
      <tr scope="row">
        <td class="p-3" style="min-width:10rem"><a href="./api-embeddings.qmd">Embeddings</a></td>
        <td class="p-3">This section includes the endpoints for calculating embeddings for protein sequences.</td>
        <td class="pe-5 pt-3">
          <ul>
            <li>Embeddings</li>
            <li>Svd</li>
          </ul>
      </tr>
      
    </tbody>
  </table>
```
