[
  {
    "objectID": "mutagenesis-page.html",
    "href": "mutagenesis-page.html",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "",
    "text": "This section is intended as a simple walkthrough of the OpenProtein.AI web app and the tools it provides for analyzing mutagenesis datasets, training sequence-to-function prediction models, using those models to predict properties for new sequences, and designing optimized libraries of sequence variants. This walkthrough uses a deep mutational scanning dataset of an aliphatic amide hydrolase from Pseudomonas aeruginosa generated by Wrenbeck et al..\nYou may download the dataset here."
  },
  {
    "objectID": "mutagenesis-page.html#upload-a-dataset",
    "href": "mutagenesis-page.html#upload-a-dataset",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Upload a dataset",
    "text": "Upload a dataset\nAfter creating your project, you will be prompted to upload a dataset. You can do so by clicking “Upload dataset” in the navigation panel or the project landing page will open a file explorer from which you can select your dataset file.\n\nWe’ll use AMIE_PSEAE_Whitehead, a deep mutational scanning dataset from Wrenbeck et al which is included as a demo dataset with this walkthrough. This dataset has activity measurements for single substitution mutants of aliphatic amidase from Pseudomonas aeruginosa on three substrates (acetamide, isobutyramide, and propionamide). This enzyme catalyzes the hydrolysis of short-chain aliphatic amides into carboxylates and ammonia.\n\n\n\nBy default, it will be the name of your uploaded file but you have the option of renaming your dataset . You can also add an optional description. If you selected the wrong file by accident, the “Change…” button will take you back to the file explorer to select a different file.\n\n\n\n\n\n\nNote\n\n\n\nA Mutagenesis dataset is expected to be uploaded as a CSV formatted table. It should have one column containing the full sequence of each variant and additional columns with measurement values associated with each variant.\nIt’s ok if some of the variants are missing measurements.\nYour sequence variants can also be specified using typical mutation codes (e.g., M1A or R25L, encoding an M-&gt;A substitution at position 1 or R-&gt;L substitution at position 25, respectively). If your table has mutation codes, you will also need to specify the full wildtype sequence in the “Sequence options” dropdown. The app will use this to enumerate the full sequence of each variant.\n\n\nThe app will try to auto-detect your sequence column based on the column name. If it can’t find the column, you can manually select it in the “Sequence options” dropdown.\n\n\n\nIf your table has variants encoded using mutant codes, you need to include the wildtype sequence of your protein.\n\n\n\nWhen you click “Upload,” your dataset will appear in the Datasets section of the navigation panel and you will be redirected to a new page for your dataset."
  },
  {
    "objectID": "mutagenesis-page.html#job-status",
    "href": "mutagenesis-page.html#job-status",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Job status",
    "text": "Job status\nView the status of your jobs in the jobs panel on the right side of the page."
  },
  {
    "objectID": "mutagenesis-page.html#visualizations",
    "href": "mutagenesis-page.html#visualizations",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Visualizations",
    "text": "Visualizations\nThe UMAP creates a 2D visualization of the manifold of your sequence variants that best reflects the similarities between your sequences in the high-dimensional feature space. You may find out more about UMAPs here\n\nIn this case, we see a star-like pattern, which reflects the fact that this dataset is single variants of the central wildtype sequence. Mutagenesis datasets with higher diversity or that are generated in less systematic ways (e.g., via selection), will tend to display different cluster structures in the UMAP plot.\nThe points are colored by their corresponding property values in your dataset. The “UMAP options” panel allows you to change the color scheme, reverse the color scheme, and toggle between multiple properties.\nIn the meantime, you can select properties to view a joint plot showing pairwise relationships between them in your dataset.\n\nThe “Dataset” tab will show your mutagenesis dataset table, allows some simple filtering and sorting of the variants, and allows you to download your dataset as a CSV with the “Export…” button.\n\nTraining model on mutagenesis dataset Next, we will train sequence-to-function prediction models on your mutagenesis dataset to predict your property(ies). These models can be used later on to make predictions for new sequence variants and to design libraries of optimized sequences. Click “Train a model…” to open the model training options panel. You can name your model and select which properties you want to be able to predict. We’ll call our model “Model” and fit it for all three properties here.\n\n\n\nClick “Start training” and you’ll see two new jobs added to your jobs panel.\n\n\n\nOnce your models finish training, they will appear in the models panel. Your models will be named according to the name you entered in the training options and the property each model predicts."
  },
  {
    "objectID": "mutagenesis-page.html#make-predictions-and-analyze-single-variant-properties",
    "href": "mutagenesis-page.html#make-predictions-and-analyze-single-variant-properties",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Make predictions and analyze single variant properties",
    "text": "Make predictions and analyze single variant properties\nOnce you have trained models, these models can be used to predict those properties for sequence variants of interest. This allows you to explore specific variants and see their predicted properties and also to examine the predicted properties of all single substitution variants of a parent sequence.\n\nRunning a prediction\nClick “Predict sequence…” or right click a sequence in the variants table and select “Predict this sequence” to go to the prediction page. Here, we sort by isobutyramide activity and select the variant with highest activity to analyze single site variants of.\n\nThis page allows you to enter an arbitrary variant sequence and make property predictions for that sequence and all single variants of it using your trained models.\n\nClick “Run a new prediction…”, select your models, and click run. This may take a few minutes if the system is busy. Feel free to navigate away. Next time you come back to this sequence, the prediction results will be stored so they can be retrieved quickly later.\n\n\n\nExamining predict results\nWhen the predict job completes, you’ll see a table with predicted property values and standard deviations for your query sequence. You’ll also see a heatmap showing the favorability of each single substitution mutant of your query sequence based on their predicted properties.\n\n\n\n\n\n\nNote\n\n\n\nImportant: open the “Show heatmap options” drawer. Here, you can edit the definition of the variant score based on the predicted property values. You can set whether a property should be greater than, less than, or as close as possible to a target value which you can set for each property. You can also toggle properties on and off using the check marks and change how the individual properties are weighted in the score. See the note on design criteria below in the “Design optimized variants” section for more information. The right side of the panel shows the relationship between variant scores and the color map. You can change the min, mid, and max values to adjust the color scaling of the heatmap.\n\n\nFor this dataset, let’s look for variants likely to have activity &gt;1 on all three substrates. We also set the min score for the colormap to -20 to get better color resolution of the possible variants.\n\nSince we started with a high activity sequence, we can see that most variants are predicted to be less likely to achieve our design criteria. These are colored red by default.\n\nThere’s only one variant that our models predict are more likely to achieve the design objective than, which is colored blue. Hovering that cell of the heatmap will show more information about it.\n\nYou can look for variants that might be better for other design objectives by editing the scoring criteria in the heatmap options drawer. For example, if we look only at isobutyramide, we can find some other substitutions that might be beneficial.\n\nYou can download the single site predictions as a CSV table with the “Export” button."
  },
  {
    "objectID": "mutagenesis-page.html#designing-optimized-variants",
    "href": "mutagenesis-page.html#designing-optimized-variants",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Designing optimized variants",
    "text": "Designing optimized variants\nPredict is useful if you want to understand the predicted properties and single mutant potentials for some specific sequences. But what if you don’t know what the best base sequence is or want to design a library of higher order mutants that optimally trade off your properties and explore sequence space? That’s what the design module is for.\n\nRunning the design tool\nReturn to the dataset page and select “Create a design…” This will take you to a new page where you can define your design objectives and then the platform will search for sequence variants most likely to achieve those objectives.\n\nHere, we want to look for variants likely to have activity &gt;1 on all substrates. You can edit the name of this design run in the name text box. We’ve changed it to “AMIE all &gt;1.” You can also specify specific positions within the sequence to mutate. If you don’t, all positions will be considered. The single site potentials found on the predict page can be a useful way to identify a limited number of positions, but we’ll just consider all positions here. You can also set the design algorithm to find optimal variants at shells of similarity to your dataset by selecting the “Use number of mutations criteria” option. This can be helpful if you want to explore tradeoffs between the number of mutations in each variant and the predicted properties. When a criteria is set for multiple properties, the algorithm will search for variants that fall along the Pareto front of those criteria. More information on the design criteria can be found here.\nBy default, the design algorithm will run for 10 steps. If you want to generate more candidate sequences and give the algorithm more time to find, potentially, better variants, this can be increased. Let’s set it to 20.\n\n\n\nThen click “Generate design” to start the algorithm. This will save the design so it’s accessible from the navigation panel. It can take some time for the algorithm to run. Once it starts, you’ll be able to see results as they are generated by the algorithm."
  },
  {
    "objectID": "mutagenesis-page.html#examining-design-results",
    "href": "mutagenesis-page.html#examining-design-results",
    "title": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "section": "Examining design results",
    "text": "Examining design results\nAs results are being generated and once the algorithm finishes, you’ll see the variant sequences generated by the design process overlaid on the UMAP. You can adjust the color settings and change the property the new points are colored by in the color options panel. The designed sequences are colored by predicted property.\n\nYou can view histograms comparing the expected property distributions for the designs against your original library and joint plots for all of the properties in the “Histogram” and “Joint plot” tabs.\n\n\nNote that these show all sequences in the design table, not just the best.\nBelow the plots, you can see the table of the generated sequences. The design algorithm may not generate all unique sequences at every step, so you can filter the table to only show unique sequences using the option in “Advanced filters.” You can sort the sequences by predicted property and the score assigned to each according to your design criteria. For score, larger (closer to zero) is better.\n\nThe filter icon next to each column name also allows you to set simple filters that can be applied to the designs.\n\n\n\nYou can now download designs and save as a library accordingly.\nThat’s it! Now you can download your designed sequence variants to perform any additional analysis and synthesize your library!"
  },
  {
    "objectID": "account-page.html",
    "href": "account-page.html",
    "title": "Account",
    "section": "",
    "text": "Login to the web platform with your username and password."
  },
  {
    "objectID": "account-page.html#logging-into-your-account",
    "href": "account-page.html#logging-into-your-account",
    "title": "Account",
    "section": "",
    "text": "Login to the web platform with your username and password."
  },
  {
    "objectID": "account-page.html#resetting-your-password",
    "href": "account-page.html#resetting-your-password",
    "title": "Account",
    "section": "Resetting your password",
    "text": "Resetting your password\nTo change your password, navigate to the account icon on the top right corner of the page, and click on ‘Change password’."
  },
  {
    "objectID": "api-introduction.html",
    "href": "api-introduction.html",
    "title": "Getting started",
    "section": "",
    "text": "Our endpoints follow an asynchronous POST and GET framework. Once you initiate a task via our POST endpoints, the system schedules the job. This means that even for tasks that may take a while to complete, your request will return immediately. Instead of waiting for the final results, you will receive a job ID in response to your initial request.\nThis job ID is a unique identifier that you can use to track your job. You can use this job ID with our GET endpoints to query the status of your task.\nIf the job is still in progress, the API will return a response indicating that the job is not yet complete. Once the job has completed, a call to the same endpoint with your job ID will allow you to retrieve your results. You can also use the /jobs endpoints to poll the status of a job before fetching all the results.\nOur API is designed this way to ensure that you are not kept waiting for long tasks to complete and can track and manage your tasks at your convenience.\nRemember, your job ID is unique and essential for retrieving the results of your task. Please keep a note of this ID once you initiate a task."
  },
  {
    "objectID": "api-introduction.html#job-system",
    "href": "api-introduction.html#job-system",
    "title": "Getting started",
    "section": "",
    "text": "Our endpoints follow an asynchronous POST and GET framework. Once you initiate a task via our POST endpoints, the system schedules the job. This means that even for tasks that may take a while to complete, your request will return immediately. Instead of waiting for the final results, you will receive a job ID in response to your initial request.\nThis job ID is a unique identifier that you can use to track your job. You can use this job ID with our GET endpoints to query the status of your task.\nIf the job is still in progress, the API will return a response indicating that the job is not yet complete. Once the job has completed, a call to the same endpoint with your job ID will allow you to retrieve your results. You can also use the /jobs endpoints to poll the status of a job before fetching all the results.\nOur API is designed this way to ensure that you are not kept waiting for long tasks to complete and can track and manage your tasks at your convenience.\nRemember, your job ID is unique and essential for retrieving the results of your task. Please keep a note of this ID once you initiate a task."
  },
  {
    "objectID": "api-introduction.html#other-user-material",
    "href": "api-introduction.html#other-user-material",
    "title": "Getting started",
    "section": "Other user material",
    "text": "Other user material\nThere is a comprehensive User Guide. with descriptions of each workflow.\nWe also provide demos of core workflows:\n\nMaking predictions based on measured properties\nMore coming soon!\n\nLastly, we have demo datasets that can be used to gain familiarity with our workflows. We encourage you to peruse these resources before starting your workflows for the optimal experience."
  },
  {
    "objectID": "api-introduction.html#contact-us",
    "href": "api-introduction.html#contact-us",
    "title": "Getting started",
    "section": "Contact Us",
    "text": "Contact Us\n\nOpenProtein - Website\nSend email to OpenProtein"
  },
  {
    "objectID": "library-page.html",
    "href": "library-page.html",
    "title": "Libraries",
    "section": "",
    "text": "Libraries serve as a repository of all your designed sequence variants. This enables you to reference previously created variants easily.\nYou can also save your library within the app. Click the “Save as library…” button and enter a name for your library.\n\n\n\nThis will take you to a new page with the sequence variants you selected. You can navigate back to these sequences from the library section of the navigation menu.\n\nThat’s it! Now you can download your designed sequence variants to perform any additional analysis and synthesize your library!"
  },
  {
    "objectID": "library-page.html#saving-sequence-variants-as-a-library",
    "href": "library-page.html#saving-sequence-variants-as-a-library",
    "title": "Libraries",
    "section": "",
    "text": "Libraries serve as a repository of all your designed sequence variants. This enables you to reference previously created variants easily.\nYou can also save your library within the app. Click the “Save as library…” button and enter a name for your library.\n\n\n\nThis will take you to a new page with the sequence variants you selected. You can navigate back to these sequences from the library section of the navigation menu.\n\nThat’s it! Now you can download your designed sequence variants to perform any additional analysis and synthesize your library!"
  },
  {
    "objectID": "dataset-page.html",
    "href": "dataset-page.html",
    "title": "Dataset upload",
    "section": "",
    "text": "A dataset is expected to be uploaded as a CSV formatted table. It should have the following columns:\n\nthe full sequence of each variant and\nadditional columns with measurement values associated with each variant.\n\n\nTo upload your dataset to the protein engineering platform, format it as a CSV table with two columns: the full sequence of each variant and additional columns with measurement values. Missing measurements are acceptable.\nIf you use mutation codes, specify the full wildtype sequence in the “Sequence options” dropdown, and the platform will enumerate the full sequence of each variant."
  },
  {
    "objectID": "dataset-page.html#preparing-your-dataset-for-upload",
    "href": "dataset-page.html#preparing-your-dataset-for-upload",
    "title": "Dataset upload",
    "section": "",
    "text": "A dataset is expected to be uploaded as a CSV formatted table. It should have the following columns:\n\nthe full sequence of each variant and\nadditional columns with measurement values associated with each variant.\n\n\nTo upload your dataset to the protein engineering platform, format it as a CSV table with two columns: the full sequence of each variant and additional columns with measurement values. Missing measurements are acceptable.\nIf you use mutation codes, specify the full wildtype sequence in the “Sequence options” dropdown, and the platform will enumerate the full sequence of each variant."
  },
  {
    "objectID": "dataset-page.html#creating-a-project",
    "href": "dataset-page.html#creating-a-project",
    "title": "Dataset upload",
    "section": "Creating a project",
    "text": "Creating a project\nUpon first login, you will be prompted to create a project. You can name the project and include a description for your reference."
  },
  {
    "objectID": "dataset-page.html#uploading-a-dataset",
    "href": "dataset-page.html#uploading-a-dataset",
    "title": "Dataset upload",
    "section": "Uploading a dataset",
    "text": "Uploading a dataset\nYou can upload your dataset by clicking on the ‘Upload dataset’ button in the navigation panel or the project landing page. This will open a file explorer where you can select your dataset file.\n\nYou have the option to edit the name of your dataset to your preference. By default, the name of the uploaded file is used. Additionally, you can add an optional description to provide more information about your dataset.To change the selected file, you can click on the “Change…” button to return to the file explorer and select a different file.\n\n\n\nThe application will automatically detect the column where your sequences are based on the column name.If the column cannot be found, you can manually input column type for each column.\n\n\n\nIf your table encodes variants using mutant codes, please ensure that you include the wildtype sequence of your protein under ‘Parent sequence’.\n\n\n\nOnce you’re ready, click “Upload” to initiate the upload process."
  },
  {
    "objectID": "predictions-page.html",
    "href": "predictions-page.html",
    "title": "Predictions",
    "section": "",
    "text": "This page allows you to enter an arbitrary variant sequence and make property predictions for that sequence and all single variants of it using your trained models. Click “Predict sequence…” or right click a sequence in the variants table and select “Predict this sequence” to go to the prediction page.\n\nClick “Run a new prediction…”, select your models, and click run. This may take a few minutes to run if the system is busy. Feel free to navigate away."
  },
  {
    "objectID": "predictions-page.html#running-a-prediction",
    "href": "predictions-page.html#running-a-prediction",
    "title": "Predictions",
    "section": "",
    "text": "This page allows you to enter an arbitrary variant sequence and make property predictions for that sequence and all single variants of it using your trained models. Click “Predict sequence…” or right click a sequence in the variants table and select “Predict this sequence” to go to the prediction page.\n\nClick “Run a new prediction…”, select your models, and click run. This may take a few minutes to run if the system is busy. Feel free to navigate away."
  },
  {
    "objectID": "predictions-page.html#prediction-results",
    "href": "predictions-page.html#prediction-results",
    "title": "Predictions",
    "section": "Prediction results",
    "text": "Prediction results\nOnce the prediction job is finished, you will be presented with a table that contains: * predicted property values and * standard deviations for your query sequence.\nStandard deviations indicate the degree of uncertainty in the predicted property value for your query. Additionally, a heatmap will be displayed that shows the favorability of each substitution mutant of your query sequence based on their predicted properties.\nTo customize the variant score based on the predicted property values, you can open the “Show heatmap options” drawer. Here, you can define the variant score by setting whether a property should be greater than, less than, or as close as possible to a target value, which you can set for each property.\n\nYou can also toggle properties on and off using the check marks, adjust how the individual properties are weighted in the score, and modify the color scaling of the heatmap by changing the minimum, mid, and maximum values."
  },
  {
    "objectID": "predictions-page.html#heatmaps",
    "href": "predictions-page.html#heatmaps",
    "title": "Predictions",
    "section": "Heatmaps",
    "text": "Heatmaps\nThe heatmap provides a means to explore alternative design objectives by adjusting the scoring criteria in the heatmap options. The \"Export\" button allows you to download the single-site predictions as a CSV table."
  },
  {
    "objectID": "api-workflow.html",
    "href": "api-workflow.html",
    "title": "Workflow",
    "section": "",
    "text": "Endpoints to upload your dataset to OpenProtein’s engineering platform for train, predict and evaluate tasks. See the User Guide. Format your data as 2 column CSV:\n\nThe full sequence of each variant (mutation codes are also accepted)\n1+ columns with your measured properties (missing values are acceptable)\n\n\n\n\nEndpoints to train a model(s) on your measured properties to enable predictions for new sequences! See the User Guide. These workflows will additionally perform cross-validation on your models to estimate uncertainty. Note: A trained model is required before you can utilize predict or design endpoints.\n\n\n\nEndpoints for predicting properties on arbitary sequences with your OpenProtein trained models! Please see the User Guide. You can make predictions for single sequences as well as single mutant variants of the sequence. Note that you must first train a model with the train endpoints (see above).\n\n\n\nEndpoints to design new sequences based on your stated objectives and our genetic algorithm! See the User Guide. Note that these endpoints require you to first upload your datasets via assaydata endpoints. You may also require trained models from the train endpoints for full utility.\n\n\n\nEndpoints to create umap visualizations of embeddings!\n\n\n\nEndpoints to calculate embeddings for protein sequences.\n\n\n\nEndpoints to query job status for asynchronous jobs."
  },
  {
    "objectID": "api-workflow.html#endpoints",
    "href": "api-workflow.html#endpoints",
    "title": "Workflow",
    "section": "",
    "text": "Endpoints to upload your dataset to OpenProtein’s engineering platform for train, predict and evaluate tasks. See the User Guide. Format your data as 2 column CSV:\n\nThe full sequence of each variant (mutation codes are also accepted)\n1+ columns with your measured properties (missing values are acceptable)\n\n\n\n\nEndpoints to train a model(s) on your measured properties to enable predictions for new sequences! See the User Guide. These workflows will additionally perform cross-validation on your models to estimate uncertainty. Note: A trained model is required before you can utilize predict or design endpoints.\n\n\n\nEndpoints for predicting properties on arbitary sequences with your OpenProtein trained models! Please see the User Guide. You can make predictions for single sequences as well as single mutant variants of the sequence. Note that you must first train a model with the train endpoints (see above).\n\n\n\nEndpoints to design new sequences based on your stated objectives and our genetic algorithm! See the User Guide. Note that these endpoints require you to first upload your datasets via assaydata endpoints. You may also require trained models from the train endpoints for full utility.\n\n\n\nEndpoints to create umap visualizations of embeddings!\n\n\n\nEndpoints to calculate embeddings for protein sequences.\n\n\n\nEndpoints to query job status for asynchronous jobs."
  },
  {
    "objectID": "api-workflow.html#apiv1",
    "href": "api-workflow.html#apiv1",
    "title": "Workflow",
    "section": "/api/v1/",
    "text": "/api/v1/"
  },
  {
    "objectID": "poet-thiolase-codehidden.html",
    "href": "poet-thiolase-codehidden.html",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "",
    "text": "This tutorial will introduce OpenProtein’s new PoET workflow, a cutting-edge protein language model designed to facilitate evaluating protein sequences from scratch, eliminating the need for functional measurements of your specific protein. With this model, you can effortlessly score candidate proteins, or generate a custom diverse library before running any wetlab experiments!\nThe core workflow in PoET is governed by a prompt, which consists of a collection of sequences that encode valuable insights into the local fitness landscape and co-evolutionary patterns associated with your protein of interest. One effective approach for constructing this prompt involves, first; generating a multiple sequence alignment (MSA) of your protein with sequences from various evolutionary lineages, and second; applying filters to that MSA to create a focussed prompt. Since these sequences share an evolutionary connection, they inherently carry information about the protein’s local fitness landscape. PoET leverages this information to both:\nWe will apply this new machine learning model to develop novel thiolase enzymes with activity against a compound of interest."
  },
  {
    "objectID": "poet-thiolase-codehidden.html#thiolase-superfamily",
    "href": "poet-thiolase-codehidden.html#thiolase-superfamily",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "Thiolase superfamily ",
    "text": "Thiolase superfamily \nThiolases play a critical role in catalyzing thioester formation — a key process in fatty acid biosynthesis in vivo. Thiolases have attracted significant research interest due to their role in catalysing thioester formation, which is a key intermediary in several industrial processes, including:\n\nPharmaceuticals: thioesters can be extensively modified with specific moieties, enabling the synthesis of a wide range of pharmaceuticals with desired properties\nBiopolymers: thiolases enable the efficient conversion of organic acids into thioesters, which are subsequently polymerized to create environmentally friendly biopolymers. For example polyhydroxyalkanoate (PHA).\nFlavours and fragrences: thioesters are key components in the synthesis of aroma compounds and flavour enhancers\n\nUnderstanding the factors that govern thiolase substrate specificity is therefore crucial. Furthermore, developing novel thiolases with improved specificity or activity may yield novel products or more efficient industrial processes.\nThis tutorial will build on the work and data made available by Robinson (2020). Robinson et al. investigated thiolase substrate specificity and activity with an extensive library of compounds and thiolases.\nWe will demonstrate how OpenProtein’s PoET model can leverage co-evolutionary data from an MSA to score sequences, generate new candidate sequences de novo, and facilitate further in-vitro testing. Our workflow will begin with a single seed sequence obtained freely from Uniprot, while the Robinson dataset will tie our observations back to experimental data, and provide an empirical validation of the trends we see in our modelling.\n\nActivity and specificity dataset \nI have reproduced figure 2 from the Robinson paper as a visual summary of the dataset; we have 15 chemical compounds of various chemical structures, and 73 thiolases from a broad range of taxonomic classes. We can note that most thiolases show activity against only a subset of compounds, and activity is highly variable (~1-3 orders of magnitude difference).\n\n\n\nCode\nimport pandas as pd \nimport json\nfrom AWSTools.Batchtools import batch_utils as bu \nimport openprotein\nfrom scipy.stats import spearmanr\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pandas import option_context\nfrom misc import  wait_for_job\nimport requests \nsns.set_style(\"whitegrid\")\n\nwith open('secrets.config', 'r') as f:\n    config = json.load(f)\nsession = openprotein.connect(config['username'], config['password'])\n\n\n\n\nLoading the data\nLet’s first load and examine the Robinson 2020 data:\n\n\nCode\ndata = pd.read_csv(\"./data/Robinson/enzyme_substrate_activity.csv\")\ndata = data.rename(columns={\"cmpnd\": \"compound\", 'log_slope':'log_activity'})\ndata['compound'] = data.compound.str.replace(\" \",\"_\")\n\n# read in sequences and match to data\nsequences = bu.fasta2csv(\"./data/Robinson//robinson.fa\")\nsequences['org'] = sequences['accession'].apply(lambda x: \" \".join( x.split('1_')[-1:])   )\nsequences['org'] = sequences.org.str.replace(\"_\",\" \")\nsequences = sequences.rename(columns={\"seq\": \"sequence\"})\n\n# manual matches\nsequences.loc[sequences.accession.str.contains(\"Halobacteriovorax\"),'org'] = \"Halobacteriovorax marinus\"\nsequences.loc[sequences.accession.str.contains(\"Enhygromyxa\"),'org'] = \"Enhygromyxa salina\"\nsequences.loc[sequences.accession.str.contains(\"Kocuria_varians\"),'org'] = \"Kocuria varians\"\nsequences.loc[sequences.accession.str.contains(\"Pseudoxanthomonas\"),'org'] = \"Pseudoxanthomonas\"\nsequences.loc[sequences.accession.str.contains(\"translucens\"),'org'] = \"Xanthomonas translucens\"\nsequences.loc[sequences.accession.str.contains(\"Leifsonia\"),'org'] = \"Leifsonia sp. Leaf325\"\nsequences.loc[sequences.accession.str.contains(\"Chloroflexi_bacterium\"),'org'] = \"Chloroflexi bacterium RBG 13 51 36\"\n\nmatched = len(set(sequences.org.unique()) & set(data.org.unique()))\n\n# merge together\ndata = data.merge(sequences, on='org', how='left')\nassert data[data.org.isna()].shape[0]==0\ndata = data.sort_values(['org','compound'])\n\nprint( f\"Matched {matched} out of {len(data.org.unique())} thiolases\" )\ndata.head(3)\n\n\nMatched 72 out of 73 thiolases\n\n\n\n\n\n\n\n\n\nfilename\ncompound\norg\nlog_activity\naccession\nsequence\n\n\n\n\n404\noutput//2019-11-22/2019-11-22_7Ph heptanoate_a...\n7Ph_heptanoate\nActinomycetospora chiangmaiensis\n1.437703\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n657\noutput//2019-12-13/2019-12-13_azido_all_data_c...\nazido\nActinomycetospora chiangmaiensis\n1.722814\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n295\noutput//2019-11-15/2019-11-15_butoxy_all_data_...\nbutoxy\nActinomycetospora chiangmaiensis\n1.989242\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n\n\n\n\n\nWe can see above the same data that corresponds to figure 2. We will need to wrangle the data a little to summarise replicates and add back in the 0 activity rows:\n\n\nCode\n# Summarize replicates\ndata = (\n    data.groupby(['org', 'compound', 'sequence'])\n    .agg(mean_log_activity=('log_activity', 'mean'),\n         std_log_activity=('log_activity', 'std'),\n         count_activity=('log_activity', 'count'))\n    .reset_index()\n)\ndata = data.fillna(0.0)\n\n# add in zero-activity rows\nnew_df = pd.DataFrame(index=pd.MultiIndex.from_product([data['org'].unique(), data['compound'].unique()],\n                                                       names=['org', 'compound']))\nnew_df['mean_log_activity'] = 0\nnew_df['std_log_activity'] = 0\n\n# update the new dataframe with the original dataframe's values\nnew_df.update(data.set_index(['org', 'compound']))\n\n# reset the index and merge\ndata = new_df.reset_index()\ndata = data.merge(sequences, on='org', how='left')\ndata.head()\n\n\n\n\n\n\n\n\n\norg\ncompound\nmean_log_activity\nstd_log_activity\naccession\nsequence\n\n\n\n\n0\nActinomycetospora chiangmaiensis\n7Ph_heptanoate\n1.437703\n0.000000\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n1\nActinomycetospora chiangmaiensis\nazido\n1.722814\n0.000000\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n2\nActinomycetospora chiangmaiensis\nbutoxy\n1.989242\n0.000000\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n3\nActinomycetospora chiangmaiensis\ncyclopentyl\n1.185503\n0.000000\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n4\nActinomycetospora chiangmaiensis\nheptynoate\n1.448957\n0.211179\nWP_026204600.1_Actinomycetospora_chiangmaiensis\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n\n\n\n\n\n\n\n\n\nCode\nfrom misc import display_side_by_side\nwith option_context('display.max_rows', None, 'display.max_columns', None):\n    display_side_by_side( [data[['compound']].value_counts().head().reset_index().rename(columns={0:'count'}), data[['org']].value_counts().head().reset_index().rename(columns={0:'count'})] , ['Compound', \"Organism\"] )\n\n\n\n\n\nCompound\n\n\n \ncompound\ncount\n\n\n\n\n0\n7Ph_heptanoate\n72\n\n\n1\nClPh_propionate\n72\n\n\n2\nTMA\n72\n\n\n3\nazido\n72\n\n\n4\nbiotin\n72\n\n\n\n   \n\nOrganism\n\n\n \norg\ncount\n\n\n\n\n0\nActinomycetospora chiangmaiensis\n14\n\n\n1\nActinoplanes atraurantiacus\n14\n\n\n2\nPaenibacillus polysaccharolyticus\n14\n\n\n3\nOkibacterium fritillariae\n14\n\n\n4\nNonomuraea candida\n14\n\n\n\n\n   \n\n\nWe have been able to reproduce most of the Robinson dataset, yielding measurements for 14 out of 15 compounds across 72 out of 73 organisms.\n\n\nExploring the data \nWe can investigate the data briefly before proceeding with PoET.\nFirst, let’s examine the sequences from each organism to get an idea of sequence diversity:\n\n\nCode\nfrom Bio import pairwise2\n\ndef align_report(seq1, seq2):\n    \"\"\"Calculate the similarity between two sequences using the globalxx alignment score\"\"\"\n    if seq1==seq2:\n        return 1\n    alignments = pairwise2.align.globalxx(seq1, seq2)\n    top_alignment = alignments[0]\n    print(pairwise2.format_alignment(*top_alignment) )\n    return pairwise2.format_alignment(*top_alignment)\n\ndef calculate_similarity(seq1, seq2):\n    \"\"\"Calculate the similarity between two sequences using the globalxx alignment score\"\"\"\n    if seq1==seq2:\n        return 1\n    alignments = pairwise2.align.globalxx(seq1, seq2)\n    top_alignment = alignments[0]\n    alignment_score = top_alignment[-3]\n    similarity = alignment_score / len(seq1)\n    return similarity\n\ndef generate_similarity_matrix(sequences):\n    \"\"\"Generate a similarity matrix for a list of sequences\"\"\"\n    num_sequences = len(sequences)\n    similarity_matrix = np.zeros((num_sequences, num_sequences))\n    for i in range(num_sequences):\n        for j in range(i+1, num_sequences):\n            similarity = calculate_similarity(sequences[i], sequences[j])\n            similarity_matrix[i, j] = similarity\n            similarity_matrix[j, i] = similarity\n    np.fill_diagonal(similarity_matrix, 1)\n    return similarity_matrix\n\n\n\n\nCode\nunique_sequences = data.drop_duplicates('org').sequence.tolist()\nunique_orgs = data.drop_duplicates('org').org.tolist()\nsimilarity_matrix = generate_similarity_matrix(unique_sequences)\n\nsimilarity_matrix = pd.DataFrame(similarity_matrix, index=unique_orgs, columns=unique_orgs)\nsns.heatmap(similarity_matrix, cmap='coolwarm', vmin=0, vmax=1)\nplt.title(\"Pairwise sequence Similarity\");\n\n\n\n\n\n\n\n\nCode\nprint(\"Sequence similarity summary:\")\nprint(f\"\\tMean: {np.mean(similarity_matrix.values[np.triu_indices(similarity_matrix.shape[0], k=1)]):.2f} \\n\\tMin: {np.min(similarity_matrix.values[np.triu_indices(similarity_matrix.shape[0], k=1)]):.2f} \\n\\tMax: {np.max(similarity_matrix.values[np.triu_indices(similarity_matrix.shape[0], k=1)]):.2f} \")\n\n\nSequence similarity summary:\n    Mean: 0.49 \n    Min: 0.36 \n    Max: 0.88 \n\n\nWe can see above that there is a lot of diversity in our sequences; the average pairwise similarity is &lt;50%. And this covers a range from 36-88% (excluding the diagonal). This diversity of sequences makes the Robinson data very useful for evolutionary prompting.\n\n\nChoosing a target candidate\nWe can now build our prompt, to do that we will first select a good compound for development (i.e. good data availability, broad range of activity and good specificity). Once we have selected our target compound we will take the most active enzyme sequence as a seed to generate an MSA, and then impose filters on that MSA to create a prompt.\nFirst, let’s see how much non-zero data is available for each compound, choosing a compound with more data will make the resulting analysis more robust:\n\n# compounds with most data\nordered_compounds = data[data.mean_log_activity!=0].compound.value_counts().index.tolist()\ndata[data.mean_log_activity!=0].compound.value_counts()[::-1].plot(kind='barh', figsize=(8, 4)); \nplt.title(\"Number of datapoints per compound\");\nplt.xlabel(\"Number of datapoints\");\n\n\n\n\nWe can see above the number of data points per compound; azido, butoxy and heptynoate have the most available data, covering &gt;90% of the enzymes.\nWe also want a target compound with a reasonable range of activities for two reasons:\n\n\nideally measurement error should be smaller than true activity differences, this is more likely for larger data ranges\n\n\na larger range suggests more scope for improved enzymatic activity, and a more interesting fitness landscape\n\n\nI’ve plotted the range of activities below per compound:\n\n\nCode\nf, ax = plt.subplots(figsize=(10, 4))\nsns.boxplot( data.query(\"mean_log_activity!=0\"), x='compound', y='mean_log_activity',ax=ax, order=ordered_compounds)\nplt.xticks(rotation=90)\nplt.title(\"Range of activity for each Compound\");\nplt.ylabel(\"Enzymatic activity (log10)\");\nplt.xlabel('');\n\n\n\n\n\nWe can see butoxy, hexanoate and heptanoate all have broad ranges of activity. Butoxy was also noted above for its data availibility.\nLastly, let’s look at enzyme specificity, here defined as the correlation in activity across compounds. Specific enzymes are usually more highly valued than promiscuous enzymes, partly due to their greater efficiency and production of fewer by-products. Therefore we want to pick a compound that will enable us to prompt for specificity (as well as activity).\n\n\nCode\ncompound_activity_corr = np.zeros((len(ordered_compounds), len(ordered_compounds)))\nfor i, compound1 in enumerate(ordered_compounds):\n    for j, compound2 in enumerate(ordered_compounds):\n        compound1_data = data[(data.compound==compound1)]\n        compound2_data = data[(data.compound==compound2)]\n        compound_activity_corr[i, j] = spearmanr(compound1_data.mean_log_activity, compound2_data.mean_log_activity)[0]\n    \ncompound_activity_corr = pd.DataFrame(compound_activity_corr, index=ordered_compounds, columns=ordered_compounds)\n\nf, ax = plt.subplots(figsize=(10, 8))\n\nsns.heatmap(compound_activity_corr, cmap='YlOrRd', vmin=0, vmax=1, ax=ax);\nplt.title(\"Spearman correlation of enzymatic activity per compound\");\n\n\n\n\n\nThis same data is summarized futher (mean correlation) in the table below:\n\n\nCode\ncompound_activity_corr.mean(axis=1).round(2).reset_index().rename(columns={0:'mean correlation'}).sort_values('mean correlation', ascending=False)\n\n\n\n\n\n\n\n\n\nindex\nmean correlation\n\n\n\n\n8\nheptanoate\n0.60\n\n\n4\nhexanoate\n0.56\n\n\n10\ndecanoate\n0.53\n\n\n2\nheptynoate\n0.51\n\n\n5\ncyclopentyl\n0.51\n\n\n9\ndodecanoate\n0.51\n\n\n6\n7Ph_heptanoate\n0.49\n\n\n0\nazido\n0.47\n\n\n7\noxadiazole\n0.42\n\n\n3\nTMA\n0.40\n\n\n1\nbutoxy\n0.39\n\n\n11\nClPh_propionate\n0.39\n\n\n12\nbiotin\n0.39\n\n\n13\ndimethyl\n0.35\n\n\n\n\n\n\n\nWe can see most specific enzymes target dimethyl, with butoxy a little further up the list.\nBased on the above findings, butoxy stands out as a promising compound to focus on for several reasons:\n\nExtensive experimental data: Butoxy has many non-zero data points.\nWide range activity: Butoxy activity spans 1-2 orders of magnitude.\nSpecificity: Butoxy is only weakly correlated to other compounds.\n\nMoreover, the most recent data available lists production of butoxy at 10-50 million pounds per year in the USA. This is used in diverse applications such as:\n\nPaint additives: plasticizers in paints improve durability and flexibility.\nCosmetics and personal care: butoxy solvents prevent ingredient separation and maintain clarity, even at high temperatures.\nHygeine and cleaning: due to its effective ability to dissolve grease and dirt.\n\nConsidering these factors, the development of an enhanced butoxy-specific thiolase would yield significant industrial benefits via potential gains in product performance, cost-effectiveness, and sustainability.\n\n\nCode\nselected_compound = 'butoxy'\n\n\nLet’s briefly examine the butoxy data a little more closely.\nBelow is the correlation between butoxy activity and every other compound in our Robinson dataset. We can see the weakest correlation is against dimethyl, ClPhpropionate and oxadiazole. These will serve as interesting negative controls later on.\n\n\nCode\ncompound_correlations = compound_activity_corr[selected_compound].sort_values().round(2)\nleast_correlated_compound = compound_correlations.index[0]\n\ncompound_correlations.reset_index().rename(columns={'index':'compound', selected_compound:'correlation'} )\n\n\n\n\n\n\n\n\n\ncompound\ncorrelation\n\n\n\n\n0\ndimethyl\n0.12\n\n\n1\nClPh_propionate\n0.16\n\n\n2\noxadiazole\n0.25\n\n\n3\nbiotin\n0.25\n\n\n4\nTMA\n0.30\n\n\n5\ndecanoate\n0.33\n\n\n6\ndodecanoate\n0.36\n\n\n7\nheptanoate\n0.40\n\n\n8\ncyclopentyl\n0.40\n\n\n9\nhexanoate\n0.42\n\n\n10\nazido\n0.47\n\n\n11\n7Ph_heptanoate\n0.48\n\n\n12\nheptynoate\n0.55\n\n\n13\nbutoxy\n1.00\n\n\n\n\n\n\n\nLet’s also take a closer look at the distribution of butoxy activity per enzyme (below), we can see this spans 1-2 orders of magnitude, with K. sedentarius having the most active thiolase:\n\n\nCode\nf, ax = plt.subplots(figsize=(10, 4))\nsns.barplot( data.query(\"compound== @selected_compound \").sort_values('mean_log_activity'), x='org', y='mean_log_activity',ax=ax, color='darkblue' )\nplt.xticks(rotation=90)\nplt.title(f\"Range of activity for {selected_compound}\");\nplt.ylabel(\"Enzymatic activity (log10)\");\nplt.xlabel('');\n\n\n\n\n\n\n\nSummary \nWe have 72 enzymes that catalyse 14 thiols with a range of activity. We have selected butoxy as our target compound due to it’s data availability and industrial importance. Kytococcus sedentarius represents the most active butoxy thiolase in our dataset."
  },
  {
    "objectID": "poet-thiolase-codehidden.html#poet-thiolase-scoring",
    "href": "poet-thiolase-codehidden.html#poet-thiolase-scoring",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "PoET thiolase scoring ",
    "text": "PoET thiolase scoring \n\nJob creation \nHaving explored the data and selected butoxy catalysis as our main goal, we can now proceed to the PoET job, and scoring all 72 enzymes.\nWe will build a prompt around the most active butoxy catalysing enzyme (from K. sedentarius), and compare our model scores with experimental data from Robinson.\n\n\nCode\nx = data.query(\"compound==@selected_compound\").sort_values('mean_log_activity', ascending=False)\nmsa_seed = x.sequence.tolist()[0]\nmsa_seed_id = x.org.tolist()[0] \nprint(f\"Selected compound: {selected_compound}\")\nprint(f\"Most active {selected_compound} enzyme: {msa_seed_id}\")\nprint(\"Enzyme sequence:\", msa_seed)\n\n\nSelected compound: butoxy\nMost active butoxy enzyme: Kytococcus sedentarius\nEnzyme sequence: MPGNATFRHSNTSVLSVTALPAPEVHTSAEFDARIMDTLRRNKLVPGVLSRLVGIKERRWWPEDVHFTEAAAEAGRRALVDAGIKPEQVGLMVNTSVSRDHLEPSTAVRIHDTLGLPRSASNFDVTNACLGFVNGMQIAAAMIDSGQIEYALIVNAETTRHTHETTLKRLESEDATADDVLQQLATLTLGSGAAAMVLGRTDKHPEGHRFVGGVSRAGTEHHELCVGDFDRMTTDSVGLQEAGIALSEELWAEAAEEFDWQHLDRYVIHQVSTVHTEQICDRLGLDGAKVPRTFPTYGNMGPAAVPFTLALEAPHLERGDRVLLMGIGSGLNACCAEIEW\n\n\n\n\nCode\n# one sequence per organism, save to file\ndata.query(\"compound==@selected_compound\")['sequence'].to_csv(\"./data/query_data.csv\", index=False)\n\n\nWe can now kick off the job!\nI will upload the query sequences (to be scored) as well as the seed sequence (to generate the MSA and prompt). For the prompt, I have selected hyper-parameters that will filter the MSA down to sequences that are at least somewhat similar to the seed sequence.\nThe exact arguments are:\n\nUse first sequence as seed to generate MSA = True (i.e. use K. sedentarius sequence to generate MSA)\nnumber of prompts to ensemble = 1 (ensemble only 1 replicate for now)\nminimum similarity to seed = 0.5 (ensure all prompt sequences have &gt;50% sequence similarity to the seed. This is important to select for butoxy activity specifically, and not just thiol activity in general)\nHomology level = 0.5 (the tolerance for redundant sequences in the prompt, sequences with &gt;0.5 similarity will be considered redundant and downsampled)\nalways include seed sequence: True (i.e. ensure K. sedentarius sequence is always included in the prompt)\nmaximum number of sequences = 50 (the total number of sequences per replicate)\nrandom seed = 42 (for reproducible results)\n\n\n\n\nCode\nresults_path = \"./results/Robinson2020/prots2prot-query.csv\"\n\nscoring_job_id = '26a43427-796e-4fc6-8c4a-31ca6109fa0b'\nevo_prompt_id = '3e581bc1-353e-4dfc-aeb4-82e1e6b5843e'\nscoring_result = pd.read_csv(results_path)\nprint(f\"Reading from {scoring_job_id}\")\nscoring_result.head(3)\n    \n\n\nReading from 26a43427-796e-4fc6-8c4a-31ca6109fa0b\n\n\n\n\n\n\n\n\n\nscores\nsequence\nscore\n\n\n\n\n0\n[-492.5433044433594]\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n-492.543304\n\n\n1\n[-703.46240234375]\nMNVGITGIAYALPAREVTTAELQRRVAPKLPPRMFEQATGITRRRV...\n-703.462402\n\n\n2\n[-219.8573303222656]\nMDGNATTTHRNVALLSVATTMATRITTSAEIDRRLAPSLKRLKLPT...\n-219.857330\n\n\n\n\n\n\n\n\n\nPrompting PoET \nLet’s examine the MSA constructed from our seed sequence (before any filtering, such as minimum similarity is applied):\n\n\nCode\nresponse = session.prots2prot.get_msa(scoring_job_id)\nmsadf = pd.DataFrame(list(response), columns=['name','sequence'])\nprint(\"Number of sequences in MSA:\", len(msadf))\nprint(\"Sample:\")\nmsadf.head(10)\n\n\nNumber of sequences in MSA: 1604\nSample:\n\n\n\n\n\n\n\n\n\nname\nsequence\n\n\n\n\n0\nseed\nMPGNATFRHSNTSVLSVTALPAPEVHTSAEFDARIMDTLRRNKLVP...\n\n\n1\nA0A892J436\nMPGNATFRHTNTSVLSVTGLPAPEVHTSAEFDARIMDTLRRNKLVP...\n\n\n2\nA0A1F1KA82\nMPGNATFRHSNTSILSVTGLPAPEVRTSAEFDERIMDTLRRNRLVP...\n\n\n3\nA0A4Q7V0T1\nMTGTALFHHDNTVIVSVCGIDAPTVVTSAEIDDRLSDTYERLELRP...\n\n\n4\nA0A516PWD2\nMSGNATYRLTNTSMLSVSAIEAPVVATSEEFDDRLEATYRRTGLRR...\n\n\n5\nA0A495XTP4\nMSGNATFRYANTAVLSVCAVDAPVVMTSDAFDEKLLETYARVGLRS...\n\n\n6\nA0A839QRV3\nMGGNATFRHDNSALLAIGSVEAPVVVTSDEFDRRLAPSLKRLRLSR...\n\n\n7\nA0A176UIU6\nMIGNATFRHRNTALLSVISVQAPRIVSSTEFDHRLASTLRRLKFPP...\n\n\n8\nA0A838H8R0\nMTGNGIFRSSNTSVLAVDALDAPRVVTSAELDERLSATYRRVGLRP...\n\n\n9\nA0A3N0C1T5\nMIGNATFRHRNTALLSVSSVEAPKVVSSAEFDHMLAPTLQRLKFPP...\n\n\n\n\n\n\n\nWe have &gt;1600 sequences in the MSA, and we told the prompt to take up to 50 (per replicate).\nLet’s see how many sequences are in the prompt:\n\n\nCode\nresponse = session.prots2prot.get_prompt(scoring_job_id, prompt_index=1)\npromptdf = pd.DataFrame(list(response), columns=['name','sequence'])\n#rename seed from 101 to uniprotkb entry \npromptdf.loc[promptdf.name=='101', 'name'] = 'C7NEV1'\nprint(\"Number of sequences in prompt:\", len(promptdf))\nprint(\"Sample:\")\npromptdf.head(10)\n\n\nNumber of sequences in prompt: 50\nSample:\n\n\n\n\n\n\n\n\n\nname\nsequence\n\n\n\n\n0\nseed\nMPGNATFRHSNTSVLSVTALPAPEVHTSAEFDARIMDTLRRNKLVP...\n\n\n1\nA0A1F1KA82\nMPGNATFRHSNTSILSVTGLPAPEVRTSAEFDERIMDTLRRNRLVP...\n\n\n2\nA0A516PWD2\nMSGNATYRLTNTSMLSVSAIEAPVVATSEEFDDRLEATYRRTGLRR...\n\n\n3\nA0A543KKX1\nMNGNATFRHHDTAVLSVTAVDAPVVKTSDDFDEVLADSYRRNGLRP...\n\n\n4\nA0A098YAU2\nMSGNATHRFSNTSILTVQTADASQVVTSDDIDQRLADTYKRVGLRP...\n\n\n5\nUPI001C43CB83\nMPGNATFHHRNASLLSVTEVQAPEVLTSKDLDKRLGDALKRLRLPT...\n\n\n6\nUPI000975AA8B\nMPGNATTHFDDVALVSVASVLPSRVTTSDDIEERLAPALKRLKLKP...\n\n\n7\nUPI001C67085F\nMSGNITFRHHDTAVLAVTAVDAPVVKTSEEFDAIIGDSYTRNGLRP...\n\n\n8\nUPI00047A1E2B\nMTGNFNFRHRNTALLGVESVEAPVIITSAEFDRILSPALRRLRLSK...\n\n\n9\nUPI001963D3D9\nMAGNAIHRFANTTVLAVCAIDAPRVVTSAEIDERLADVYTRVSLRP...\n\n\n\n\n\n\n\nThe prompt filtering resulted in 50 sequences, including the seed sequence (C7NEV1). Exactly as expected (though &lt;50 would also be expected with more stringent filtering).\nWe can also sense-check that the prompt doesn’t simply contain the query sequences:\n\n\nCode\n# Use all the prompts combined\nresponse = session.prots2prot.get_prompt(scoring_job_id)\npromptdf = pd.DataFrame(list(response), columns=['name','sequence'])\npromptdf = promptdf.drop_duplicates().reset_index(drop=True)\nprint(\"Total sequences across all replicates:\", promptdf.shape[0])\n\n\nTotal sequences across all replicates: 50\n\n\n\n\nCode\nprint(f\"Number of overlapping sequences in prompt and query: {len(set(unique_sequences) & set(promptdf.sequence.unique().tolist()))}\")\nx = [i for i in unique_sequences if i in promptdf.sequence.unique().tolist()]\ndata.query(\"compound==@selected_compound\").set_index('sequence').loc[ x ]\n\n\nNumber of overlapping sequences in prompt and query: 2\n\n\n\n\n\n\n\n\n\norg\ncompound\nmean_log_activity\nstd_log_activity\naccession\n\n\nsequence\n\n\n\n\n\n\n\n\n\nMPGNATFRHSNTSVLSVTALPAPEVHTSAEFDARIMDTLRRNKLVPGVLSRLVGIKERRWWPEDVHFTEAAAEAGRRALVDAGIKPEQVGLMVNTSVSRDHLEPSTAVRIHDTLGLPRSASNFDVTNACLGFVNGMQIAAAMIDSGQIEYALIVNAETTRHTHETTLKRLESEDATADDVLQQLATLTLGSGAAAMVLGRTDKHPEGHRFVGGVSRAGTEHHELCVGDFDRMTTDSVGLQEAGIALSEELWAEAAEEFDWQHLDRYVIHQVSTVHTEQICDRLGLDGAKVPRTFPTYGNMGPAAVPFTLALEAPHLERGDRVLLMGIGSGLNACCAEIEW\nKytococcus sedentarius\nbutoxy\n2.968362\n0.087611\nWP_012802190.1_Kytococcus_sedentarius\n\n\nMSENASYRLANCSILSVSTVEAPEVVTSDHLDELLQPAYDTTGMMAGQIERLAGVRERRWFPKDADYTRGAVEAGRQAIADARIDADRIGLIVNASVTRPHLEPGISAMVHAELELPRSCIAFDVTNACLGVVNSLQIAGTMIDAGQIEYALIVASEGARQMQEASIARLVDGGSRQDVKDAFATMTLGSGAVGIVLGRSDRHPEGHQIIGGITRAGTEHHELCIGGMDGMRTDASKLFVEGLSLATDAWAEAKGEWDWEEMDWYVAHQTSTAHIACLCDTLKLPAEKFPVTVDTYGNIGPVALPFTLGMYQHKMRKGDRVLLMGIGSGLNTSMTEVRW\nMobilicoccus massiliensis\nbutoxy\n2.360310\n0.106454\nWP_040156198.1_Mobilicoccus_massiliensis\n\n\n\n\n\n\n\n\n\nCode\nprint(f\"Sequence similarity K. sedentarius v  M. massiliensis: {calculate_similarity(x[0], x[1]):.2f}\")\n\n\nSequence similarity K. sedentarius v  M. massiliensis: 0.56\n\n\nAs well containing the original seed (as requested in our prompt definition), the prompt also contains a sequence from Mobilicoccus massiliensis (which is also part of the Micrococcales order, and also highly active against butoxy - so no surprise our MSA captured it).\nThe remaining 48 sequences are from organisms not in our dataset. Let’s try to find these in Uniprot. As the MSA uses ColabFold, which contains metagenomic and transcriptomic data, we may not find all the sequences in the UniProtKB. These will be marked notfound below:\n\n\nCode\nprompt_orgs = [] \nfor accnumber in promptdf.name.unique()[0:]:\n    if accnumber == '101':\n         continue \n    r = requests.get(f\"https://www.uniprot.org/uniprotkb/{accnumber}.json\", timeout=3)\n    prompt_orgs.append((accnumber, r.json().get('organism', {}).get('scientificName', 'notfound'), r.json().get('organism', {}).get('lineage', [] )))\n\npromptdf = pd.DataFrame(prompt_orgs, columns=['accnumber', 'organism', 'lineage']).merge(promptdf, left_on='accnumber', right_on='name')\n# we know M. massiliensis \nassert promptdf.loc[promptdf.accnumber=='UPI00059046A7', 'sequence'].tolist()[0]== data.loc[data.org=='Mobilicoccus massiliensis', 'sequence'].tolist()[0]\npromptdf.loc[promptdf.accnumber=='UPI00059046A7', 'organism'] = 'Mobilicoccus massiliensis'\npromptdf.organism.value_counts()\n\n\norganism\nnotfound                                                                            24\nPlantibacter sp. VKM Ac-1784                                                         1\nPirellulimonas nuda                                                                  1\nBrevibacterium luteolum                                                              1\nLysobacter sp. Root604                                                               1\nXanthomonas sacchari                                                                 1\nLysobacter sp                                                                        1\nNakamurella sp. PAMC28650                                                            1\nAcidimicrobiia bacterium                                                             1\nhydrothermal vent metagenome                                                         1\nMicrobacterium halimionae                                                            1\nEgicoccus halophilus                                                                 1\nQuadrisphaera granulorum                                                             1\nbacterium (Candidatus Blackallbacteria) CG17_big_fil_post_rev_8_21_14_2_50_48_46     1\nKytococcus sp. HMSC28H12                                                             1\nActinomycetia bacterium                                                              1\nMicrolunatus antarcticus                                                             1\nMicrolunatus flavus                                                                  1\nMobilicoccus massiliensis                                                            1\nPseudoclavibacter sp. RFBA6                                                          1\nTessaracoccus antarcticus                                                            1\nGeodermatophilus sp. LHW52908                                                        1\nGeorgenia soli                                                                       1\nModestobacter caceresii                                                              1\nOrnithinimicrobium humiphilum                                                        1\nMicrolunatus elymi                                                                   1\nWenzhouxiangella sp. W260                                                            1\nName: count, dtype: int64\n\n\nWe can see above we were able to ascertain the origins of just over half the prompt sequences, suggesting the other half came from metagenomic or transcriptomic sources.\nBelow, I have summarised the taxonomic order for the sequences present in UniProtKB:\n\n\nCode\npromptdf.loc[promptdf['lineage'].apply(len) &gt;=3].lineage.apply(lambda x: x[2]).value_counts()\n\n\nlineage\nMicrococcales             7\nPropionibacteriales       4\nGammaproteobacteria       4\nGeodermatophilales        2\nKineosporiales            1\nNitriliruptoria           1\necological metagenomes    1\nAcidimicrobiia            1\nNakamurellales            1\nPlanctomycetia            1\nName: count, dtype: int64\n\n\nWe can see the prompt is quite diverse, containing 10 different taxonomic orders.\n\n\nScoring results \nWe can now turn to the PoET results. PoET modelling will return a log-liklihood (LL) score to evaluate the fitness of our queries against the prompt. The higher the score (i.e. less negative) the better the sequence (the more fit).\nWe can download our results for further analysis from the UI:\n\n\n\nCode\nscoring_result.head()\n\n\n\n\n\n\n\n\n\nscores\nsequence\nscore\n\n\n\n\n0\n[-492.5433044433594]\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n-492.543304\n\n\n1\n[-703.46240234375]\nMNVGITGIAYALPAREVTTAELQRRVAPKLPPRMFEQATGITRRRV...\n-703.462402\n\n\n2\n[-219.8573303222656]\nMDGNATTTHRNVALLSVATTMATRITTSAEIDRRLAPSLKRLKLPT...\n-219.857330\n\n\n3\n[-328.9368896484375]\nMRGNATTRHSNVALLGITEAVAPVEVSSKSFDDRLADTLKTLRLPK...\n-328.936890\n\n\n4\n[-766.7886352539062]\nMTYSRIGQIAVHLPEGGRTSAEVEALVAELNPGFEPPEGLIERFTG...\n-766.788635\n\n\n\n\n\n\n\nWe expect 72 results, one for each enzyme uploaded:\n\n\nCode\nprint(scoring_result.shape[0], \"results found\")\ncompound_scores = scoring_result.merge(data.query(\"compound==@selected_compound\"), on='sequence')\n\n\n72 results found\n\n\nNow let’s see how well our PoET model scores correlate with the experimental activity data against butoxy:\n\n\nCode\nx = compound_scores.query(\"mean_log_activity&gt;0\") # drop 0 active rows\nr,p = spearmanr(x['score'], x['mean_log_activity'])\nr,p = np.round(r,2), np.round(p,2)\nprint(f\"Spearman correlation between score and mean_log_activity: {r:.2f}, p={p:.2f}\")\n\nf, axs = plt.subplots(1,1, figsize=(12,6), sharex=True)\nax = axs\n# full results\nsns.regplot(data=x,\n            x='mean_log_activity',\n            y='score',\n            scatter_kws={'s': 5, 'alpha': 0.5},\n            n_boot=100,\n            robust=True,\n            ax=ax )\nax .set_xlabel(\"Experimental \")\nax .set_ylabel(\"Model score\")\n# add spearmanr r and p results to graph\nax .text(0.05, 0.9, f\"spearman r={r:.2f}\\np-value ={p:.2f}\", transform=plt.gca().transAxes, size=14);\nax.set_title(f\"Correlation between {selected_compound} and log-liklihood score\\n MSA seed: {msa_seed_id}\");\n\n\nSpearman correlation between score and mean_log_activity: 0.41, p=0.00\n\n\n\n\n\nExcellent, a &gt;0.4 correlation (p&lt;0.05) between activity and model score with just a single sequence, and no wetlab data!\nWe can also examine how it performed against compounds that were weakly correlated with butoxy to check specificity (see the reminder below) .\n\n\nCode\nprint(\"Weakest correlation to butoxy activity:\")\ncompound_correlations.head(3).reset_index().rename( columns={'index':'compound', selected_compound:'correlation'} )\n\n\nWeakest correlation to butoxy activity:\n\n\n\n\n\n\n\n\n\ncompound\ncorrelation\n\n\n\n\n0\ndimethyl\n0.12\n\n\n1\nClPh_propionate\n0.16\n\n\n2\noxadiazole\n0.25\n\n\n\n\n\n\n\nGiven the nature of the prompt we supplied, we expect there to be very little correlation between our model scores and experimental activity for these 3 compounds:\n\n\nCode\nf, axs = plt.subplots(1,3,figsize=(15,5), sharex=True, sharey=True)\naxs = axs.flatten()\n\nfor i, compound in  enumerate(compound_correlations.index.tolist()[0:3]):\n    x = scoring_result.merge(data.query(\"compound==@compound\"), on='sequence')\n    x = x.query(\"mean_log_activity!=0\")\n    r,p = spearmanr(x['score'], x['mean_log_activity'])  \n    sns.regplot(data=x,\n                x='mean_log_activity',\n                y='score',\n                scatter_kws={'s': 5, 'alpha': 0.5},\n                n_boot=100,\n                robust=True,\n                ax=axs[i] )\n    axs[i].set_ylabel(\"model score\")\n    axs[i].set_xlabel(\"Activity (log10)\")\n    # add spearmanr r and p results to graph\n    axs[i].set_title(f\"{compound} vs score {r=:.2f}, {p=:.2f}\");\nplt.tight_layout()\n\n\n/opt/conda/envs/py38/lib/python3.8/site-packages/statsmodels/robust/robust_linear_model.py:288: ConvergenceWarning: Estimated scale is 0.0 indicating that the most last iteration produced a perfect fit of the weighted data.\n  warnings.warn('Estimated scale is 0.0 indicating that the most'\n\n\n\n\n\nAs expected, our p-values are all &gt;0.05, indicating a non-significant relationship between fitness (which we defined using a butoxy thiolase) and experimental activity against dimethyl, ClPh propionate and oxadiazole! This suggests our prompt was succesful in encoding the features that make our butoxy thiolase specific and active!\nNote that the key to success here is two things (in order of importance):\n\nminimum similarity sets a floor in how similar our prompt sequences are to the K. sedentarius seed. This is important as we need our prompt to reflect butoxy activity specifically (and not thiolases in general).\nhomology level sets a ceiling on redundant sequences, ensuring the prompt is still diverse even after the minimum similarity step.\n\nFor reference, you can see the results from the default prompt settings (min. similarity = 0, homology level =0.8) in the appendix. This yields a correlation coefficient of 0.26 (p=0.03). Which is significant, but far below the 0.4 with the more thoughtful prompt above.\n\n\nPoET scoring Summary \nThis is a data-free way to start interrogating sequences for fitness, in this example, we took a series of thiolases and created a prompt to reflect butoxy catalysing activity. We achieved this by using the most active enzyme for butoxy catalysis as a seed for an MSA, and then a series of filters to ensure the resulting prompt looked reasonably like the original enzyme.\nWe then tested the results of this approach across 72 thiolases from 10 different taxonomic classes. This resulted in a strong (&gt;0.4) spearman correlation between PoET model scores and experimental activity. We confirmed that this was a specific effect by comparing those same scores to dimethyl (and other weakly correlated thiols) catalysis - and found no significant relationship (as expected)."
  },
  {
    "objectID": "poet-thiolase-codehidden.html#poet-de-novo-thiolase-generation",
    "href": "poet-thiolase-codehidden.html#poet-de-novo-thiolase-generation",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "PoET de novo thiolase generation ",
    "text": "PoET de novo thiolase generation \n\nJob creation \nNow that we have a meaningful prompt, we can re-use it to generate entirely new sequences. We can use these new sequences to understand butoxy thiolases, and to explore sequence and structural constraints in butoxy catalysis. Additionally, we could run these through wetlab assays to generate more data, and start exploring the fitness landscape with empirical observations. For now, we will focus on computational insights.\nTo kick off the PoET generation job we will supply a few key arguments:\n\nNumber of sequences to generate = 50\ntop-k = 10 (at each step, sample from only the 10 most likely amino acids).\nMaximum generated protein length = 500 (i.e. stop generating any protein beyond this size)\n\nWe have left the following arguments at their default value:\n\ntemperature = 1.0 (this will control the creativity of the model, higher temperatures lead to more diverse output. 1.0 is a good default value)\ntop-p = 1.0 (this is an alternative to top-k, where we sample from the amino acids within cumulative p probability distribution)\n\n\n\n\nCode\ngen_results_path = \"./results/Robinson2020/Robinson_generate.csv\"\n\ngen_job_id = '5597d678-0bc9-4828-90af-2527e6898977'\nprint(f\"Reading from job {gen_job_id}\")\ngen_score_result = pd.read_csv(gen_results_path)\ngen_score_result = gen_score_result.sort_values(by='score', ascending=False).reset_index(drop=True)\ngen_score_result['name'] = [f\"gen-{i+1}\" for i in range(gen_score_result.shape[0])]\ngen_score_result[['name','sequence']].to_csv(\"./results/Robinson2020/colabfold_input.csv\", index=False)\n\n\nReading from job 5597d678-0bc9-4828-90af-2527e6898977\n\n\n\n\nEvaluating generated sequences \nWe have generated a variety of sequences with different scores, let’s first download the novel sequences and scores like we did previously:\n\n\n\nCode\ngen_score_result.head()\n\n\n\n\n\n\n\n\n\nscores\nsequence\nscore\nname\n\n\n\n\n0\n[-105.93228149414062]\nMSENATYRLANTSVLSVSTIEAPEVVTSDHLDELLQPAYDSTGMMA...\n-105.932281\ngen-1\n\n\n1\n[-114.87188720703125]\nMGRNATHRFGNTSVLSVCAIEAPRTITSAEIDERLAPVYQRVGLRA...\n-114.871887\ngen-2\n\n\n2\n[-121.16313171386719]\nMNGNTSWRAANTALLSVTAVEAPVVVTSDELDERLAGPMARLGIRA...\n-121.163132\ngen-3\n\n\n3\n[-133.42160034179688]\nGNATTRFANVSLLSVASRLPSRVTPSTQIQERLGAAMTRLRLPPRL...\n-133.421600\ngen-4\n\n\n4\n[-142.5845947265625]\nMSGNATFRLTNTAILAVTTVEAPEVITSEQLDERLRATYDRIGMTP...\n-142.584595\ngen-5\n\n\n\n\n\n\n\nBelow I have plotted:\n\n(top) the distribution of generated sequence scores (red) against all 72 sequences in our data (grey)\n(bottom) generated sequence scores (red) against a subset of highly active sequences (light blue - defined as being more active than the median enzyme).\n\nWe can see the scores of the generated sequences are generally right-shifted, suggesting greater fitness (defined, as we saw above, as butoxy catalysis):\n\nf, axs = plt.subplots(2,1, figsize=(12,6), sharex=True, sharey=True)\nplt.suptitle(\"Generated sequence scores\")\naxs[0].set_title(\"Generated sequences vs all experimental sequences\")\naxs[0].hist(gen_score_result.score, bins=20, alpha=0.5, color='red', label='PoET sequences');\naxs[0].hist(compound_scores.score, bins=20, alpha=0.2, color='grey', label='All experimental sequences');\naxs[0].legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\naxs[0].set_ylabel( \"Number of sequences\")\n\nmedian_activity = compound_scores.mean_log_activity.median()\naxs[1].set_title(\"Generated sequences vs active experimental sequences\")\naxs[1].hist(gen_score_result.score, bins=20, alpha=0.5, color='red', label='PoET sequences');\naxs[1].hist(compound_scores.query(\"mean_log_activity&gt;@median_activity\").score, bins=20, alpha=0.4, color='lightblue', label='All active sequences');\naxs[1].legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\naxs[1].set_ylabel( \"Number of sequences\")\nplt.xlabel(\"model score\");\n\n\n\n\nWe can also examine the similarity of our generated sequences; first to each other, and then to the prompt sequences. To make the plotting easier, I have named each sequence in order of descending score (so gen-1 is the highest scoring sequence, and gen-50 the lowest, with gen-25 being the median scoring sequence).\n\n\nCode\ngenerated_sequences = gen_score_result.sequence.tolist()\ngen_similarity_matrix = generate_similarity_matrix(generated_sequences)\n\ngen_similarity_matrix = pd.DataFrame(gen_similarity_matrix, index=gen_score_result.name.tolist(), columns=gen_score_result.name.tolist())\nsns.heatmap(gen_similarity_matrix, cmap='coolwarm', vmin=0, vmax=1)\nplt.title(\"Pairwise sequence Similarity (Generated sequences)\");\n\n\n\n\n\n\n\n\nCode\nprint(\"Sequence pairwise-similarity statistics (generated sequences):\")\nprint(f\"\\tMean: {np.mean(gen_similarity_matrix.values[np.triu_indices(gen_similarity_matrix.shape[0], k=1)]):.2f} \\n\\tMin: {np.min(gen_similarity_matrix.values[np.triu_indices(gen_similarity_matrix.shape[0], k=1)]):.2f} \\n\\tMax: {np.max(gen_similarity_matrix.values[np.triu_indices(gen_similarity_matrix.shape[0], k=1)]):.2f} \")\n\n\nSequence pairwise-similarity statistics (generated sequences):\n    Mean: 0.59 \n    Min: 0.50 \n    Max: 0.78 \n\n\nWe can see our 50 generated sequences are quite diverse, they have a mean pairwise similarity of &lt;0.6, and a range of 0.5-0.78.\n\n\nCode\nseed_gen_sim = []\nfor i,seq in enumerate(generated_sequences):\n    seed_gen_sim.append( calculate_similarity(msa_seed, seq) )\ngen_score_result['seed_similarity'] = seed_gen_sim\n\n\nLet’s see how they compare to the seed sequence we used to generate the MSA and prompt:\n\n\nCode\nf, ax = plt.subplots(1,1, figsize=(10,5))\nplt.title(f\"Sequence similarity: Generated vs {msa_seed_id} seed \")\nsns.barplot(data=gen_score_result, x=\"name\", y=\"seed_similarity\", ax=ax, color='darkblue')\nplt.xticks(rotation=90);\nplt.xlabel(\"Sequence name\")\nplt.ylabel(\"Sequence similarity\");\n# add hline at 1 \nax.axhline(1, ls='--', color='red', alpha=0.5);\n\n\n\n\n\nSequences are on average ~60% similar to the seed sequence. This is roughly in line with our expectations, as we saw our diverse group of thiolases that catalyze all 14 compounds have approximately 50% sequence similarity. We would expect butoxy specific enzymes to be somewhat higher than that broad thiolase baseline.\nWe can also see below that there is no significant relationship between the similarity to the seed and the model score for the generated sequences: this suggests the prompt is doing a good job (and not overfitting):\n\n\nCode\nr,p = spearmanr(gen_score_result['score'], gen_score_result['seed_similarity'])\nprint(f\"Spearman correlation between score and seed similarity: {r:.2f}, p={p:.2f}\")\n\nf, axs = plt.subplots(1,1, figsize=(12,6), sharex=True)\nax = axs\n# full results\nsns.regplot(data=gen_score_result,\n            x='seed_similarity',\n            y='score',\n            scatter_kws={'s': 5, 'alpha': 0.5},\n            n_boot=100,\n            robust=True,\n            ax=ax )\nax .set_xlabel(\"Similarity to seed\")\nax .set_ylabel(\"Model score\")\n# add spearmanr r and p results to graph\nax .text(0.05, 0.9, f\"spearman r={r:.2f}\\np-value ={p:.2f}\", transform=plt.gca().transAxes, size=14);\nax.set_title(f\"Seed sequence similarity vs model score\");\n\n\nSpearman correlation between score and seed similarity: 0.10, p=0.49\n\n\n\n\n\n\n\nCode\nfrom multiprocessing import Pool\n\ndef calculate_similarity_wrapper(args):\n    return calculate_similarity(*args)\n\ndef generate_similarity_distinct(sequences1, sequences2):\n    \"\"\"Generate a similarity matrix for a list of sequences\"\"\"\n    num_sequences1 = len(sequences1)\n    num_sequences2 = len(sequences2)\n\n    with Pool() as p:\n        similarity_matrix = np.array(p.map(calculate_similarity_wrapper, [(seq1, seq2) for seq1 in sequences1 for seq2 in sequences2]))\n    \n    return similarity_matrix.reshape(num_sequences1, num_sequences2)\n\n\nLastly, let’s look at the sequence similarity between the prompt sequences (below heatmap, Y axis) and the generated sequences (X axis):\n\n\nCode\ncompared_sim = generate_similarity_distinct(generated_sequences , promptdf.sequence.tolist() )\ncompared_sim = pd.DataFrame(compared_sim, index=gen_score_result.name.tolist(), columns=promptdf.name.tolist()).T\n\n\nf, ax = plt.subplots(1,1, figsize=(8,12), sharex=True)\nsns.heatmap(compared_sim, cmap='coolwarm', vmin=0, vmax=1, ax=ax)\nplt.title(\"Pairwise sequence Similarity\");\n\n\n\n\n\n\n\nCode\nprint(f\"Summary statistics for pairwise generated v prompt comparison: \")\nprint(f\"\\t Mean similarity: {compared_sim.mean(axis=None):.2f}\")\nprint(f\"\\t Max similarity: {compared_sim.max(axis=None):.2f}\")\nprint(f\"\\t Min similarity: {compared_sim.min(axis=None):.2f}\")\n\n\nSummary statistics for pairwise generated v prompt comparison: \n     Mean similarity: 0.58\n     Max similarity: 0.94\n     Min similarity: 0.32\n\n\nAgain, we can see mean similarity is low (within expectations).\nThere are a few hotspots for the top sequences, I’ve investigated these below by plotting the maximum similarity to any prompt sequence, for each generated sequence:\n\n\nCode\ngen_score_result = gen_score_result.merge( compared_sim.max(axis=0).reset_index().rename(columns={'index':'name', 0:'max_prompt_similarity'}) , on='name', how='left')\n\nax = compared_sim.max(axis=0).plot(kind='bar', figsize=(15, 5));\nplt.ylabel(\"Max. similarity\")\nax.axhline(1, ls='--', color='red', alpha=0.5);\nplt.title(\"Generated sequence similarity to any prompt sequence\");\n\n\n\n\n\n\n\nCode\nprint(f\"Average max similarity to prompt across all generated sequences: {compared_sim.max(axis=0).mean():.2f}\")\n\n\nAverage max similarity to prompt across all generated sequences: 0.75\n\n\nWe see there appears to be a general trend of higher scoring sequences being more closely related to a prompt sequence (above). This is to be expected, our scoring is defined by our prompt, so sequences more similar to the prompt will score higher (by definition). We could tweak additional parameters in the PoET generate workflow if we wanted to increase, or decrease the “creativity” of the model (for example temperature, or top p).\nLet’s take two sequences;\n\nthe best scoring (gen-1)\nthe median scoring (gen-25)\n\nAnd further investigate their relationship to the prompt.\nFirst, we can see the full results for prompt sequence similarity for the best sequence (gen-1) below. Note that for this sequence, the mean similarity to the prompt sequences is 56% (range: 46-94%).\n\n\nCode\nbest_generated_sequence = gen_score_result.sequence.tolist()[0]\n\nprint(\"Prompt similarity summary for gen-1:\")\nprint(f\"\\tmean: {compared_sim['gen-1'].mean():.2f}\")\nprint(f\"\\tmin: {compared_sim['gen-1'].min():.2f}\")\nprint(f\"\\tmax: {compared_sim['gen-1'].max():.2f}\")\n\n\nPrompt similarity summary for gen-1:\n    mean: 0.56\n    min: 0.46\n    max: 0.94\n\n\n\n\nCode\nf, axs = plt.subplots(1,1, figsize=(5,15), sharex=True, sharey=False)\n\nsns.barplot(data=compared_sim['gen-1'].sort_values(ascending=False).reset_index(), x='gen-1', y='index', ax=axs, color='darkblue', orient='h')\naxs.set_ylabel(\"\")\nplt.yticks(size=8)\naxs.set_xlabel(\"Similarity\")\naxs.set_title(\"Best generated sequence vs prompt\");\naxs.axvline(1, ls='--', color='red', alpha=0.5);\n\n\n\n\n\n\n\nCode\nprint(\"Best-generated sequence, closest prompt sequence:\")\npromptdf[promptdf.accnumber==compared_sim['gen-1'].idxmax()]\n\n\nBest-generated sequence, closest prompt sequence:\n\n\n\n\n\n\n\n\n\naccnumber\norganism\nlineage\nname\nsequence\n\n\n\n\n16\nUPI00059046A7\nMobilicoccus massiliensis\n[]\nUPI00059046A7\nMSENASYRLANCSILSVSTVEAPEVVTSDHLDELLQPAYDTTGMMA...\n\n\n\n\n\n\n\nThe best scoring sequence actually shares 93.5% identity with the M. massiliensis we saw previously (and know to be an active butoxy thiolase). We therefore expect this sequence to perform well in any wetlab experiment.\nTurning to the median scoring sequence:\n\n\nCode\nf, axs = plt.subplots(1,1, figsize=(5,15), sharex=True, sharey=False)\nmedian_name = f'gen-{len(gen_score_result)//2}'\n\nsns.barplot(data=compared_sim[median_name].sort_values(ascending=False).reset_index(), x=median_name, y='index', ax=axs, color='darkblue', orient='h')\naxs.set_ylabel(\"\")\naxs.set_xlabel(\"Similarity\")\naxs.set_title(\"Median generated sequence vs prompt\")\naxs.axvline(1, ls='--', color='red', alpha=0.5);\nplt.tight_layout();\n\n\n\n\n\n\n\n\nCode\nmedian_generated_sequence = gen_score_result.sequence.tolist()[len(gen_score_result)//2]\n\nprint(\"Prompt similarity summary for gen-25:\")\nprint(f\"\\tmean: {compared_sim['gen-25'].mean():.2f}\")\nprint(f\"\\tmin: {compared_sim['gen-25'].min():.2f}\")\nprint(f\"\\tmax: {compared_sim['gen-25'].max():.2f}\")\n\n\nPrompt similarity summary for gen-25:\n    mean: 0.60\n    min: 0.49\n    max: 0.71\n\n\n\n\nCode\nprint(\"Median-generated sequence, closest prompt sequence:\")\npromptdf[promptdf.accnumber==compared_sim['gen-25'].idxmax()]\n\n\nMedian-generated sequence, closest prompt sequence:\n\n\n\n\n\n\n\n\n\naccnumber\norganism\nlineage\nname\nsequence\n\n\n\n\n19\nA0A1H9FJA5\nMicrolunatus flavus\n[Bacteria, Actinomycetota, Propionibacteriales...\nA0A1H9FJA5\nMTGNATYELKDTAVLSVCAVEAPVVVTSEAFDERLMRSYERTGLKP...\n\n\n\n\n\n\n\nThe median scoring sequence shows a more uniform similarity to prompt sequences (mean: 60%, range: 49-71%). Note that the closest prompt sequence derives from Microlunatus flavus, but at 71% similarity we expect significant divergence from this organism’s thiolase.\n\n\nCode\nprint(f\"M. flavus in Robinson dataset: {promptdf[promptdf.accnumber==compared_sim['gen-25'].idxmax()].sequence.tolist()[0] in data.sequence.tolist()}\")\n\n\nM. flavus in Robinson dataset: False\n\n\nThe sequences selected above represent two good case studies for futher evaluation. One sequence is the most fit sequence generated by PoET, whilst the median sequence should more closely reflect the bulk of the data. We will investigate these structurally below.\n\n\nInvestigating generated thiolase structures\nRobinson reports a conserved Cys across all thiolases that is buried in the active site and vital for activity, we can see this below, at position 129 in the MSA seed Kytococcus sedentarius structure from uniprot (note this is an alphafold prediction of the enzyme, as the structure is yet to be solved experimentally).\n\n\nCode\n[f\"Cys{i+1}\" for i in range(len(msa_seed)) if msa_seed[i]=='C']\n\n\n['Cys129', 'Cys225', 'Cys280', 'Cys334', 'Cys335']\n\n\n\nNote the key Cys129-His269 interaction in the active site below (vital for the thiolase “ping-pong” reaction mechanism). As well as the stabilising non-covalent interaction between Gly301 and the same His269. It is likely that this stabilising His-Gly hydrogen bonding pattern has a role in active site dynamics.\n\nFirst, since we know the active site Cys is so important to catalytic activity, and that loss of this Cys would completely ablate activity, let’s examine the Cys residues in our two generated sequences of interest:\n\n\nCode\nseq_of_interest = ['gen-1', 'gen-25'] # best scored 3 + median\n\nfor name in seq_of_interest:\n    seq = gen_score_result.loc[gen_score_result.name==name, 'sequence'].tolist()[0]\n    x = calculate_similarity(msa_seed, seq)\n    print(f\"Sequence similarity of {msa_seed_id} and {name}= {x:.2f}\")\n    print(f\"Cys positions for {name}:\", [i+1 for i in range(len(seq)) if seq[i]=='C'])\n    print()\n\n\nSequence similarity of Kytococcus sedentarius and gen-1= 0.56\nCys positions for gen-1: [120, 129, 224, 277, 279]\n\nSequence similarity of Kytococcus sedentarius and gen-25= 0.66\nCys positions for gen-25: [98, 120, 129, 225, 335]\n\n\n\nWe can see above that both our best, and median sequence, have a conserved Cys129.\n\n\nStructural analysis\n\nBest scoring generated sequence\nFor a more thorough evaluation we can also fold these sequences with Alphafold, and run a pairwise structural aligner with the original seed sequence.\nWe can see the results below for the best generated sequence, with the active site Cys highlighted in the enzyme’s core:\n\nseed (green)\ngenerated (orange):\n\nWe can see there is an overwhelming structural similarity between our seed and our best generated sequence, despite only having 56% sequence identity.\n\nZooming in on the active site, we see the same Cys-His interaction as the seed sequence’s structure (numbered Cys129-His268 in this generated sequence).\n\nLooking at the full ensemble of 5 models that AlphaFold produced (below), we can see there is overall agreement for both the Cys (yellow) and Histidine (blue) in the generated sequence across predictions, this may suggest there is little uncertainty or flexibility around these residues.\n\nThis matches both the K. sedentarius and M. massiliensis AphaFold predictions. I’ve reproduced the M. massiliensis 5 model ensemble below for illustration:\n\nAn interesting difference however, is that the His269-Gly301 stabilizing non-covalent interaction in the seed structure has been replaced by a His268-Gln269 interaction in our generated structure:\n\nOverall, we can see a high degree of structural similarity, with a few key active site differences. The overall RMSD between the seed and best generated sequence is &lt;1A:\n\nWe can also compare this generated sequence to it’s closest prompt sequence (which had a 94% sequence identity):\nFirst at the sequence level (below) which shows significant similarity:\n\n\nCode\nmost_similar_prompt_sequence = promptdf.loc[promptdf.name == compared_sim['gen-1'].sort_values().index.tolist()[-1] , 'sequence'].tolist()[0]\naligned = align_report(most_similar_prompt_sequence, best_generated_sequence)\n\n\nMSENAS-YRLANC-SI-LSVSTV-EAPEVVTSDHLDELLQPAYDT-TGMMAGQIERLAGVRERRWFPKDADYTR-GAVEAGRQAI-ADARIDADRIGLIVNASVTRPHLEPGI-SAMV-HAELELPRSCIAFDVTNACLGVVNSLQIAG-TMIDAGQIEY--ALIVAS-EGARQMQEASIARLV-DGGSRQDVKDAFATMTLGSGAVGIVLGRS-DRHPEGHQ-IIGGITRAGT-EHHELCIGGMDGMRTDAS-KLFVEGLSLATDAWAEAKGEWDWEEMDWYVAHQTSTAHIACLCDTLKLP-A-EKFPVTVDTYGNIGPVALPFTLGMYQH-KMRKGDRVLLMGIGSGLNTSMT-EVRW\n|||||  |||||  |  |||||  ||||||||||||||||||||  |||||||||||||||||||||||||||  |||||||||  ||||||||||||||||||||||||||  || | |||||||||||||||||||||||||||||  ||||||||    |||| | ||||||||||||||  ||||||||||||||||||||||||||||  |||||||  |||||||||  |||||||||||||||||  |||||||||||||||||||||||||||||||||||||||||||||||   | ||||||||||||||||||||||||||  |||||||||||||||||||||  ||||\nMSENA-TYRLAN-TS-VLSVST-IEAPEVVTSDHLDELLQPAYD-STGMMAGQIERLAGVRERRWFPKDADYT-QGAVEAGRQA-MADARIDADRIGLIVNASVTRPHLEPG-VSA-VVHAELELPRSCIAFDVTNACLGVVNSLQIA-ATMIDAGQI--DNALIV-SSEGARQMQEASIARL-LDGGSRQDVKDAFATMTLGSGAVGIVLGR-ADRHPEGH-RIIGGITRAG-SEHHELCIGGMDGMRTDA-RKLFVEGLSLATDAWAEAKGEWDWEEMDWYVAHQTSTAHIACLCDTLK--VAPEKFPVTVDTYGNIGPVALPFTLGMYQ-QKMRKGDRVLLMGIGSGLNTSM-AEVRW\n  Score=317\n\n\n\n\n\nCode\nstart = 250 \nstop = 310\nprint(f\"Alignment at ~250-310 region:\")\nfor i in range(3):\n    print(aligned.split(\"\\n\")[i][start:stop])\n\n\nAlignment at ~250-310 region:\nDAS-KLFVEGLSLATDAWAEAKGEWDWEEMDWYVAHQTSTAHIACLCDTLKLP-A-EKFP\n||  |||||||||||||||||||||||||||||||||||||||||||||||   | ||||\nDA-RKLFVEGLSLATDAWAEAKGEWDWEEMDWYVAHQTSTAHIACLCDTLK--VAPEKFP\n\n\nInterestingly, the M. massiliensis structure (below, AlphaFold), shows a different hydrogen bonding pattern for His268, despite the sequence conservation (above). The M. massiliensis structure lacks any stabilising hydrogen bonding between His268 and adjacent residues. This differs to both the K. sedentarius structure (where Gly301 provides support) and the generated sequence above (where Gln269 provides support). Given that the K. sedentarius and M. massiliensis thiolases were amongst the most active for butoxy, there is reason to believe this generated sequence, which borrows from both, would also be highly active against butoxy.\n\nOverall, we can see there is a strong structural similarity between our best scoring generated sequence and both the seed sequence and it’s closest prompt sequence; this is reflected in the alignment results, which show a &lt;1A RMSD. Additionally we see strong evidence for conservation at the active site, specifically the Cys-His interaction. Interestingly the stabilising hydrogen bonding pattern differs between all three sequences. And despite the strong sequence similarity between our sequence and M. massiliensis, our structure has elements more reminscent of K. sedentarius (e.g. the stabilising hydrogen bonding around the active site Histidine). Given these shared elements from two of the best butoxy thiolases in our dataset, we would expect this sequence to perform well in any wetlab assay.\n\n\nMedian scoring sequence\nLet’s now look at the median generated sequence, which has a much lower maximum sequence similarity to any sequence in the prompt (71%). We will follow the same workflow, and look for similar patterns in the active site that might indicate specificity or activity:\nFirst, we can see the overall alignment between this sequence and the seed sequence is good, RMSD is again &lt;1A.\n\nFocussing on the active site (below), we see His269 and Cys129 are conserved again, likely preserving the core “ping-pong” catalytic mechanism. However, the Gln269-His268 interaction that we saw in the best generated sequence, is absent here (reminiscent of M. massiliensis).\nThere is a Gly301 in the vicinity of the active site Histidine, but this Glycine is distanced from His269, suggesting those stabilizing hydogen bonds we saw in the seed structure will be transient or non-existent here. This may have repercussions for active site volume and solvent accessibility, and therefore activity and specificity (as noted by Robinsin et al. 2020).\n\nExamining the AlphaFold ensemble of 5 models (below), we see clear agreement on the Cys129 orientation, but less agreement on the positioning of the active site Histidine (blue) than either K. sedentarius, M. massiliensis or the best generated sequence. This may suggest more flexibility around His269, potentially due to the weaker non-covalent interactions discussed above:\n\nIf we examine the sequence similarity between this median generated sequence and it’s most similar prompt sequence (below) we see less conservation overall, as expected from its low sequence similarity percentage:\n\n\nCode\nmost_similar_prompt_sequence = promptdf.loc[promptdf.name == compared_sim['gen-25'].sort_values().index.tolist()[-1] , 'sequence'].tolist()[0]\naligned = align_report(most_similar_prompt_sequence, median_generated_sequence)\n\n\nMTG-NAT----YELKDT---AVL-SVCA-VEA--PV-VVTSEAFDERLMRSYE-RT-G--LK----PGMVEQ-L----AGVRE-RRWWP--ED--VTFADA--A-AM--AGAK--ALAEAGV---DPSQVGLLI-NTSVC-RDGIE---PAN--A-AGVHDQ--LGLAT-SCL---NFDVT-NACLGFL-NG-IQ-LAGS--LIDS-G-QVE-YALLV----DAEGL-RGL-QESTLA---RLAQ--DDA-TA-EDLKLQF-A---TLTLGSGSAAM--VL-GR-ASE--HPEG--HR-VTGGVS-RSG--TQHKD--LCWA--DLTQ---MR-TDSRA--LFEA--GIE-L-----AGQTWQ-DALEGREWADA--DWFIAHQTSV-----V-HLQAMAKV--VG-----VPDEKFPKT-V-------P-TF----GNL---ASAAV-PF-TL---AKQVPMIK---PGQQV--ILL--GI-GSGLNTSFA--EII--W\n||  |      |        | | ||   | |  |  |||| |  | |    | |  |  ||    |    | |    ||||  ||     |   |   |   | |   ||    ||||||    |  ||| || ||||  |   |   |    | | ||    |||   |     ||||  ||||||  |  |  ||    ||   | ||  || ||    ||    |   ||   |   ||    ||  |  |    || |   ||||||| ||   |  |  |    ||    || | |||  |    |||    ||    |      |  ||  |  |     |   |     |   |  ||   |    |  ||      |      | | |    |  |      |      |  |       | |     ||    ||    |  ||   |      |   ||     | |  |  ||||||  |  |    |\nMT-RN--SNINY-----RNSA-LLSV--SV-ADAP-EVVTS-A--E-L----EQR-LGPTLKRLRLP----QGLLSRVAGVR-ARR---SYE-PGV---D-FEAGA-VEAG--RRALAEAG-IRTD--QVG-LIINTSV-TR---EHLEP--SVAVA-VH--HRLGL--PS--SAMNFDV-ANACLGF-VN-AI-TLA--ATLI--EGGQV-DYA-LVVNGEDA---QR--VQE---ATIERL--NTDD-VT-RE----QFMAEFATLTLGSG-AA-AAV-VG-PA--DRHP--DSHRIV-GGV-TR--AATQH--HALC--IGD---HHGM-FTD--AQGL---LRG--GLDLVLDA---W-SDA---R----ANWDW------S-QMDRYVTH-Q----VSSV-HTNSIV------K-AVNIDADRVPVT-YPELGN-VGPAS---LP-LTLSREA------KHLAPG---DRI-LCMG-VGSGLNT--AMLE--LEW\n  Score=180\n\n\n\nInterestingly, we see evidence for strong conservation around the Cys129 residue (see below: the NACL motif is conserved):\n\nBut less conservation around the His269 at the sequence level:\n\nThis pattern of conservation (structure and sequence) at the Cys129 position, with non-conservation at the His269 position is likely to have implications for activity.\nOverall, the generate functionality of PoET has yielded a sequence with low identity but high structural fidelity. This median scoring sequence shows only 66% identity to the seed, and 71% to the closest prompt sequence. Despite this low sequence level similarity, the structures are remarkably similar, and the active sites have been preserved very carefully. Furthermore, the changes in secondary support for the active site are likely to effect protein dynamics and activity and warrant further study.\n\n\n\nGenerated sequences summary \nWe have generated 50 sequences de novo by using an MSA of our butoxy catalysing enzyme as a prompt. We previously saw that sequence fitness scored by protsprot correlated well with butoxy activity (but not with dimethyl, or other compounds). We therefore might expect these novel sequences to show similar activity and specificity against butoxy.\nUtilizing AlphaFold, we were able to show that 2 representative sequences (the best, and the median) align with the seed sequence structure to within 1A RMSD, despite having low sequence identity to the seed (50-60%) and, in the case of the median sequence, low identity to any prompt sequence (mean: 60%, max: 71%). Furthermore, these generated sequences preserve a vital Cys-His interaction in the active site, but differ in how they stabilize the active site His with surrounding non-covalent interactions. We hypothesize that these secondary differences may influence substrate activity and specificity and warrant further study.\nOverall, these sequences (or a subset of them) could be progressed to wetlab evaluation to assess for improved activity over our K. sedentarius sequence. This would then generate more data that could be used in OpenProtein’s suite of tools to engineer increasingly active and specific thiolases!"
  },
  {
    "objectID": "poet-thiolase-codehidden.html#additional-figures",
    "href": "poet-thiolase-codehidden.html#additional-figures",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "Additional figures:",
    "text": "Additional figures:\n\nFull results for compound activity vs model score:\n\n\nCode\nf, axs = plt.subplots(len(compound_correlations)//2, 2,  figsize=(15,15), sharex=True, sharey=True)\naxs = axs.flatten()\nplt.suptitle(\"Model score vs compound activity:\\n all compounds\", y=1.02)\nfor i, compound in  enumerate(compound_correlations.index.tolist()):\n    x = scoring_result.merge(data.query(\"compound==@compound\"), on='sequence')\n    x = x.query(\"mean_log_activity&gt;0\")\n    r,p = spearmanr(x['score'], x['mean_log_activity'])  \n    sns.regplot(data=x,\n                x='mean_log_activity',\n                y='score',\n                scatter_kws={'s': 5, 'alpha': 0.5},\n                n_boot=100,\n                robust=True,\n                ax=axs[i] )\n    axs[i] .set_ylabel(\"\")\n    axs[i].set_xlabel(\"\")\n    # add spearmanr r and p results to graph\n    axs[i].set_title(f\"{compound} {r=:.2f}, {p=:.2f}\");\naxs[len(compound_correlations)-2].set_xlabel(\"log10 activity\")\naxs[len(compound_correlations)-1].set_xlabel(\"log10 activity\")\naxs[len(compound_correlations)-2].set_ylabel(\"Model score\")\n\nplt.tight_layout()"
  },
  {
    "objectID": "poet-thiolase-codehidden.html#additional-prompts",
    "href": "poet-thiolase-codehidden.html#additional-prompts",
    "title": "Tutorial: Generating substrate specific thiolases with PoET ",
    "section": "Additional prompts:",
    "text": "Additional prompts:\n\nScoring with default parameters yields a weaker model: \nThe default prompt settings (as used below) are:\n\nUse first sequence as seed to generate MSA = True (as before)\nnumber of prompts to ensemble = 1\nminimum similarity to seed = 0.0\nHomology level = 0.8\nalways include seed sequence: False\nmaximum number of sequences = 0\nmaximum number of amino acids = 12000\n\n\n\nCode\nresults_default_prompt = \"./results/Robinson2020/prots2prot-query-defaultprompt.csv\"\n\nscoring_defaultprompt_job_id = '0d1576e5-f954-453f-ba4e-d5c218701946'\nscoring_result_defaultprompt = pd.read_csv(results_default_prompt)\nprint(f\"Reading from {scoring_defaultprompt_job_id}\")\nscoring_result_defaultprompt.head(3)    \n\n\nReading from 0d1576e5-f954-453f-ba4e-d5c218701946\n\n\n\n\n\n\n\n\n\nscores\nsequence\nscore\n\n\n\n\n0\n[-497.7345581054688]\nMRAAQRYDDVVITGLAHVDAPHVVTSTELEDRLAGTLGRLRITPGL...\n-497.734558\n\n\n1\n[-329.5821228027344]\nMNVGITGIAYALPAREVTTAELQRRVAPKLPPRMFEQATGITRRRV...\n-329.582123\n\n\n2\n[-232.86839294433597]\nMDGNATTTHRNVALLSVATTMATRITTSAEIDRRLAPSLKRLKLPT...\n-232.868393\n\n\n\n\n\n\n\n\n\nCode\nx = scoring_result_defaultprompt.merge(data.query(\"compound==@selected_compound\"), on='sequence')\nx = x.query(\"mean_log_activity&gt;0\")\nr,p = spearmanr(x['score'], x['mean_log_activity'])\nprint(f\"Spearman correlation between score and mean_log_activity: {r:.2f}, p={p:.2f}\")\n\nf, axs = plt.subplots(1,1, figsize=(12,6), sharex=True)\nax = axs\n# full results\nsns.regplot(data=x,\n            x='mean_log_activity',\n            y='score',\n            scatter_kws={'s': 5, 'alpha': 0.5},\n            n_boot=100,\n            robust=True,\n            ax=ax )\nax .set_xlabel(\"Experimental \")\nax .set_ylabel(\"Model score\")\n# add spearmanr r and p results to graph\nax .text(0.05, 0.9, f\"spearman r={r:.2f}\\np-value ={p:.2f}\", transform=plt.gca().transAxes, size=14);\nax.set_title(f\"Correlation between {selected_compound} and log-liklihood score\\n Default prompt. \");\n\n\nSpearman correlation between score and mean_log_activity: 0.26, p=0.03\n\n\n\n\n\n\n\nCode\nresponse = session.prots2prot.get_prompt(scoring_defaultprompt_job_id, prompt_index=1)\ndefaultpromptdf = pd.DataFrame(list(response), columns=['name','sequence'])\n#rename seed from 101 to uniprotkb entry \ndefaultpromptdf.loc[defaultpromptdf.name=='101', 'name'] = 'C7NEV1'\nprint(\"Number of sequences in prompt:\", len(defaultpromptdf))\nprint(\"Sample:\")\ndefaultpromptdf.head(10)\n\n\nNumber of sequences in prompt: 40\nSample:\n\n\n\n\n\n\n\n\n\nname\nsequence\n\n\n\n\n0\nA0A1F9RVZ1\nRYDKVYLAGLGYELAPVVVDTAEIEERLKPALAALRIAEGQIESLT...\n\n\n1\nA0A810ML27\nPVGITAVASVLPDREVTTADLQQRVAAASNLPLPPGMFAQATGIDR...\n\n\n2\nA0A354ZDY2\nKVMPLFWGYTGSACVPMALAVSRGRIRSGDLVTLVGSGVGYNAGVALL\n\n\n3\nA0A3N1ARH3\nVGITGVGVSLPDRTLTTADLQDRVAAASDVVLPPGLFATMTGIGQR...\n\n\n4\nA0A367YQ38\nMKTDATYQLNNTAICSAVAVEAPDRVTSAWIDEQLAETYQRLGMTP...\n\n\n5\nA0A1V5NTN6\nFSRVFLESIGYELPHNIITSTWIEERLSPLYKKLFLQPGQLEALTG...\n\n\n6\nA0A535XU34\nMAGREVKYATRQLTESSLTALREGMSVDDIDQFLFHQANLRIIESV...\n\n\n7\nUPI0003B5A6F3\nMNGNATTRHNNVALLAVASTIAPRITTSHEIDQQLAPVLKRLRLPQ...\n\n\n8\nA0A7X8QXU4\nRFQKACISSIGYELGPVVVTSDALEARIAPVYKSLGLPLGQLQGLT...\n\n\n9\nA0A0K1PEU7\nRWSRVCIEAIAYELPDERVTSSALEARLAPVYEALRLGGGQLEALT...\n\n\n\n\n\n\n\n\n\nCode\nprint(f\"Number of overlapping sequences in default args prompt and query: {len(set(unique_sequences) & set(defaultpromptdf.sequence.unique().tolist()))}\")\nx = [i for i in unique_sequences if i in defaultpromptdf.sequence.unique().tolist()]\n\n\nNumber of overlapping sequences in default args prompt and query: 0\n\n\n\n\nCode\nprompt_orgs = [] \nfor accnumber in defaultpromptdf.name.unique()[0:]:\n    if accnumber == '101':\n         continue \n    r = requests.get(f\"https://www.uniprot.org/uniprotkb/{accnumber}.json\", timeout=3)\n    prompt_orgs.append((accnumber, r.json().get('organism', {}).get('scientificName', 'notfound'), r.json().get('organism', {}).get('lineage', [] )))\n\ndefaultpromptdf = pd.DataFrame(prompt_orgs, columns=['accnumber', 'organism', 'lineage']).merge(defaultpromptdf, left_on='accnumber', right_on='name')\ndefaultpromptdf.organism.value_counts()\n\n\norganism\nnotfound                                                5\nElusimicrobia bacterium                                 3\nDesulfobacteraceae bacterium                            2\nPlanctomycetota bacterium                               2\nAcidobacteria bacterium                                 2\nDesulfobulbaceae bacterium BRH_c16a                     1\nOpitutae bacterium                                      1\nCandidatus Aminicenantes bacterium                      1\nDeltaproteobacteria bacterium RIFOXYD12_FULL_57_12      1\nMyxococcales bacterium                                  1\nOligosphaeraceae bacterium                              1\nPuniceicoccaceae bacterium                              1\nCandidatus Wallbacteria bacterium HGW-Wallbacteria-1    1\nRoseimaritima ulvae                                     1\nStreptomyces lavendulae subsp. lavendulae               1\nAcidimicrobiales bacterium                              1\nActinomycetia bacterium                                 1\nElusimicrobia bacterium GWA2_69_24                      1\nGammaproteobacteria bacterium                           1\nHalobacteriovoraceae bacterium                          1\nRickettsiales bacterium                                 1\nAcidimicrobium sp                                       1\ncandidate division KSB3 bacterium                       1\nPlanctomycetales bacterium                              1\nVulgatibacter incomptus                                 1\nChloroflexi bacterium                                   1\nbacterium ADurb.Bin374                                  1\nDesertihabitans brevis                                  1\nMicromonospora sp. Llam0                                1\nFirmicutes bacterium                                    1\nHalobacteriovorax sp                                    1\nName: count, dtype: int64\n\n\nInterestingly, our default prompt contains neither the K. sedentarius or M. massiliensis sequence. And is drawn from a much larger range of taxonomic orders. This likely is including thiolases other than butoxy thiolases.\n\n\nCode\ndefaultpromptdf['seed_similarity'] = [calculate_similarity(msa_seed, s) for s in defaultpromptdf.sequence ]\npromptdf['seed_similarity'] = [calculate_similarity(msa_seed, s) for s in promptdf.sequence ]\n\n\n\n\nCode\nf, ax = plt.subplots(1,1, figsize=(12,6), sharex=True)\nsns.histplot(data=defaultpromptdf, x='seed_similarity', bins=20, label='default prompt',alpha=0.7, ax=ax)\nsns.histplot(data=promptdf, x='seed_similarity', bins=20, label='performant prompt',alpha=0.7, ax=ax)\nplt.legend()\nplt.title(f\"Prompt sequence similarity to {msa_seed_id} seed\")\nplt.xlabel(f\"Similarity\");\n\n\n\n\n\nWe can see above the prompt produced with the default args contains sequences that are far more divergent than our performant prompt used in section 2. This is likely a symptom of the taxonomic diversity and likely the cause of the poor performance with the default prompt.\n\n\nCode\n# Full results from default prompt args job\nf, axs = plt.subplots(data.compound.nunique()//2, 2,  figsize=(15,15), sharex=True, sharey=True)\naxs = axs.flatten()\nplt.suptitle(\"Correlation between experimental activity and model score\\n Default prompt\", y=1.02)\nfor i, compound in  enumerate(data.compound.unique()):\n    x = scoring_result_defaultprompt.merge(data.query(\"compound==@compound\"), on='sequence')\n    x = x.query(\"mean_log_activity&gt;0\")\n    r,p = spearmanr(x['score'], x['mean_log_activity'])  \n    sns.regplot(data=x,\n                x='mean_log_activity',\n                y='score',\n                scatter_kws={'s': 5, 'alpha': 0.5},\n                n_boot=100,\n                robust=True,\n                ax=axs[i] )\n    axs[i] .set_ylabel(\"\")\n    axs[i].set_xlabel(\"\")\n    # add spearmanr r and p results to graph\n    axs[i].set_title(f\"Default prompt: {compound} {r=:.2f}, {p=:.2f}\");\naxs[len(compound_correlations)-2].set_xlabel(\"log10 activity\")\naxs[len(compound_correlations)-1].set_xlabel(\"log10 activity\")\naxs[len(compound_correlations)-2].set_ylabel(\"Model score (default prompt)\")\n\nplt.tight_layout()\n\n\n/opt/conda/envs/py38/lib/python3.8/site-packages/statsmodels/robust/robust_linear_model.py:288: ConvergenceWarning: Estimated scale is 0.0 indicating that the most last iteration produced a perfect fit of the weighted data.\n  warnings.warn('Estimated scale is 0.0 indicating that the most'"
  },
  {
    "objectID": "api-poet.html",
    "href": "api-poet.html",
    "title": "PoET",
    "section": "",
    "text": "Endpoints to perform multiple sequence alignment (MSA) workflows for PoET. See the User Guide.\nYou can create a multiple sequence alignment from a seed sequence, upload a custom MSA, or even upload your own prompt for use with PoET endpoints!\n\n\n\nEndpoints to call our generative Protein Evolutionary Transformer (PoET) model for de novo generation of proteins, evaluation of protein fitness, and single site mutant analysis of proteins. These workflows are all possible without prior wetlab data, and therefore do not require assaydata to be pre-loaded!\nNote that PoET requires a prompt, (ie. a set of sequences representing the target protein sequence distribution). This will commonly be an evolutionary context prompt in the form of filtered MSAs (Align). But you can use whatever collection of sequences your workflow requires!\nSee the User Guide for more information."
  },
  {
    "objectID": "api-poet.html#endpoints",
    "href": "api-poet.html#endpoints",
    "title": "PoET",
    "section": "",
    "text": "Endpoints to perform multiple sequence alignment (MSA) workflows for PoET. See the User Guide.\nYou can create a multiple sequence alignment from a seed sequence, upload a custom MSA, or even upload your own prompt for use with PoET endpoints!\n\n\n\nEndpoints to call our generative Protein Evolutionary Transformer (PoET) model for de novo generation of proteins, evaluation of protein fitness, and single site mutant analysis of proteins. These workflows are all possible without prior wetlab data, and therefore do not require assaydata to be pre-loaded!\nNote that PoET requires a prompt, (ie. a set of sequences representing the target protein sequence distribution). This will commonly be an evolutionary context prompt in the form of filtered MSAs (Align). But you can use whatever collection of sequences your workflow requires!\nSee the User Guide for more information."
  },
  {
    "objectID": "api-poet.html#apiv1poet",
    "href": "api-poet.html#apiv1poet",
    "title": "PoET",
    "section": "/api/v1/poet",
    "text": "/api/v1/poet"
  },
  {
    "objectID": "cross-validation-page.html",
    "href": "cross-validation-page.html",
    "title": "Model diagnostics and cross validation",
    "section": "",
    "text": "The app will also automatically evaluate the predictive performance of these models using cross validation once the models finish training. Navigate to the “Diagnostics” tab to see training curves and cross validation of the models.\nFor cross validation, we split your variants into 5-folds, and, for each fold, fit the model on the other 4, then make predictions on the heldout fold. The cross validation plots show the predicted properties versus your actual measured properties for each variant in your dataset when it was heldout. In the example below, we can see that the model predictions correlate strongly with the ground truth measurements, indicating that these models are able to accurately predict substrate activity for unseen sequence variants."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Open Protein AI - User Guide",
    "section": "",
    "text": "This user guide provides a basic overview of the OpenProtein.AI web app. You can create your first project, upload a dataset, and then use the OpenProtein.AI tools to analyze that dataset, train sequence-to-function prediction models, predict properties for new sequences, and design optimized libraries. It also overviews the generative modeling capabilities of the PoET model."
  },
  {
    "objectID": "index.html#at-a-glance",
    "href": "index.html#at-a-glance",
    "title": "Open Protein AI - User Guide",
    "section": "",
    "text": "This user guide provides a basic overview of the OpenProtein.AI web app. You can create your first project, upload a dataset, and then use the OpenProtein.AI tools to analyze that dataset, train sequence-to-function prediction models, predict properties for new sequences, and design optimized libraries. It also overviews the generative modeling capabilities of the PoET model."
  },
  {
    "objectID": "index.html#introduction-to-openprotein",
    "href": "index.html#introduction-to-openprotein",
    "title": "Open Protein AI - User Guide",
    "section": "Introduction to OpenProtein",
    "text": "Introduction to OpenProtein\nThis article gives an overview of the platform and its features. It is a good place to start to learn how to use the platform and what it can offer."
  },
  {
    "objectID": "index.html#demo-datasets",
    "href": "index.html#demo-datasets",
    "title": "Open Protein AI - User Guide",
    "section": "Demo datasets",
    "text": "Demo datasets\nThis article consists of links to download the walkthrough dataset and several other demo datasets."
  },
  {
    "objectID": "index.html#ml-guided-mutagenesis-and-sequence-to-function-modeling-walkthrough",
    "href": "index.html#ml-guided-mutagenesis-and-sequence-to-function-modeling-walkthrough",
    "title": "Open Protein AI - User Guide",
    "section": "ML-guided mutagenesis and sequence-to-function modeling walkthrough",
    "text": "ML-guided mutagenesis and sequence-to-function modeling walkthrough\nA simple walkthrough of the OpenProtein.AI web app and the tools it provides for analyzing mutagenesis datasets, training sequence-to-function prediction models, using those models to predict properties for new sequences, and designing optimized libraries of sequence variants. This walkthrough uses a deep mutational scanning dataset of an aliphatic amide hydrolase from Pseudomonas aeruginosa generated by Wrenbeck et al.."
  },
  {
    "objectID": "index.html#generative-modeling-and-variant-fitness-prediction-with-poet",
    "href": "index.html#generative-modeling-and-variant-fitness-prediction-with-poet",
    "title": "Open Protein AI - User Guide",
    "section": "Generative modeling and variant fitness prediction with PoET",
    "text": "Generative modeling and variant fitness prediction with PoET\nPoET is a guidable, retrieval-augmented generative model of protein sequences. It conditions on homologues or protein family representatives to predict variant effects and allow diverse sequence design de novo. PoET can be used to score and rank arbitrary sequence variants, exhaustively map single substitution mutations, and design bespoke, potentially high diversity, and novel sequences. PoET can be used to score and design substitutions, insertions, deletions, and high order combinations thereof."
  },
  {
    "objectID": "poet-tutorial-page.html",
    "href": "poet-tutorial-page.html",
    "title": "Tutorial: Designing de novo variant libraries using PoET",
    "section": "",
    "text": "PoET is a generative protein language model that allows you to design protein sequences de novo, without functional measurements of your protein of interest. This means that you can use the model to generate single substitution, combinatorial variant libraries, or a bespoke high-diversity library, prior to making any measurements.\nPoET controls sequence generation via a prompt, which is defined as a set of sequences that encodes information about the local fitness landscape and co-evolutionary patterns of your given protein of interest. One way to build this prompt is by using a multiple sequence alignment (MSA) of your protein of interest using sequences across evolutionary lineages. Because these sequences share an evolutionary relationship, they contain information about the local fitness landscape of the protein. PoET is able to infer the evolutionary process driving the generation of these sequences, and hence not only sample new sequences, but also score the likelihood of seeing a given sequence under this process.\nChorismate mutase is a important enzyme involved in the biosynthesis of aromatic amino acids. Specifically, it catalyzes the conversion of chorismate to prephenate. In this tutorial, we will use PoET to generate a prospective de novo variant library for chorismate mutase."
  },
  {
    "objectID": "poet-tutorial-page.html#generating-single-substitution-libraries",
    "href": "poet-tutorial-page.html#generating-single-substitution-libraries",
    "title": "Tutorial: Designing de novo variant libraries using PoET",
    "section": "Generating single-substitution libraries",
    "text": "Generating single-substitution libraries\nTo generate single-substitution libraries, we can use the Single site analysis prediction tool. This tool generates and scores all single-substitution variants of the given query sequence.\n\n\n\nFirst, define the query sequence for which we wish to generate all single substutions.\nNext, define the prompt. Recall that this is a set of sequences that implicitly describe the local fitness landscape of your protein of interest. The easiest way to do this is to paste the same query sequence and simply ask the tool to automatically generate the MSA from it. Here, our query sequence is the sequence encoding chorismate mutase in E. coli.\n&gt;E. coli chorismate mutase\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDI\nDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n\n\n\nInput the query sequence\n\n\nAlternatively, if you already have an MSA or some other set of sequences that you wish to use as the prompt, you can also drop or select your own file.\n\n\n\nInput the custom prompt\n\n\nAnd that’s all we need for the analysis! Click Run at the bottom of the page to generate and score all single site variant libraries. There are several other advanced options that we may want to play with after our initial run. However, the default options have been tuned to generate a reasonable starter library.\nWhen the run is complete, navigate to the Result tab to inspect the output of the run. At the top of the page is a summary detailing the score for the query sequence, as well as the number of sites and number of variants expected to improve over the input. The full results are presented as a heatmap, which you can mouse over for more detail. For convenience, the tables at the bottom of the page list the top 5 variants and sites.\n\n\n\n\n\n\nNote\n\n\n\nThe score assigned by PoET is the log likelihood of the sequence under the model. This means that the larger (less negative) the score, the higher the probability of observing the sequence given the model.\n\n\nAs we can see, position 40 seems like a promising candidate for mutagenesis, with many mutations such as L&gt;D, L&gt;E and L&gt;A all improving over the query sequence.\n\n\n\nInspect the results\n\n\nThe full results are available for export either as a csv or as a png. To do so, you can use the export button located at the top right hand corner of the page. Alternatively, you can also start a new single-site run against the same prompt either by selecting a particular variant sequence in the heatmap or in the table. Then, start a new single site analysis using Run new....\n\n\n\nExport or start a new analysis\n\n\nCongratulations! You have now created your first de novo variant library using PoET!"
  },
  {
    "objectID": "poet-tutorial-page.html#generating-high-diversity-libraries",
    "href": "poet-tutorial-page.html#generating-high-diversity-libraries",
    "title": "Tutorial: Designing de novo variant libraries using PoET",
    "section": "Generating high-diversity libraries",
    "text": "Generating high-diversity libraries\nWhy should we care about generating high-diversity libraries? The typical strategy in protein engineering is to search the local sequence space near a known sequence by generating single and combinatorial variant libraries. However, this may not be the best strategy for several reasons:\n\nYou may not have a good starting sequence. In this case, you will want to cast your net as wide as possible by sampling a variety of stable and functional proteins. However, you still don’t want to be generating biologically impossible proteins.\nYou started with an ok sequence, but are stuck in a local optima. This means that there may be distant sequences that have even higher activity. However, these either cannot be found via a simple greedy optimization strategy, or may take an unreasonable number of steps to reach it.\n\n\n\n\nThis greedy algorithm is going in the direction of the best local improvement but is actually moving further away from the global peak.\n\n\n\nYou want to hedge your bets. Unfortunately, similar sequences are likely to share other possibly unwanted, but correlated properties. For example, a set of similar sequences may all have high activity but may also all be unstable or poorly expressed. Just as with investing, it is good to diversity your portfolio.\n\nTo generate high-diversity libraries, we can use the Generate sequences tool.\n\n\n\nAs in the single-site analysis tool, we have to specify the prompt. We will again use the sequence for chorismate mutase in E. coli. to seed the MSA. Since chorismate mutase is a relatively short protein, we will set the maximum generated protein length to 200. We also set the number of sequences to generate to 100. Hitting run then dispatches the generate job.\n&gt;E. coli chorismate mutase\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDI\nDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n\n\n\nGenerate sequences\n\n\nNavigate to the Result tab to take a look at the generated sequences. Recall that the larger (less negative) the score, the higher the likelihood of the sequence under the model. We can use the table widget to filter our sequences to have some minimum score, and then export them for further analysis.\n\n\n\nFilter sequences to have a minimum score\n\n\nHowever, looking at the table, we can already observe that only 1 sequence has a score higher than the original query sequence that we input in the original analysis. To generate more highly-scoring sequences, we might want to lower Top-p, which reduces the randomness of the sampling by only sampling from the top most likely amino acids up to the specified cumulative frequency. We can also lower the temperature, which emphasizes higher probability amino acids during sampling by raising the probability to the power of the temperature.\nLet’s try setting Top-p to 0.9! Here we can see that there are a lot more high-scoring sequences.\n\n\n\nSet Top-p to 0.9\n\n\n\n\n\n\n\n\nNote\n\n\n\nHover the tooltips to learn about how the different parameters affect the results! Although we have set reasonable defaults for many of these parameters, we recommend that you also try playing around with them to customize your libraries."
  },
  {
    "objectID": "poet-tutorial-page.html#how-good-are-my-libraries",
    "href": "poet-tutorial-page.html#how-good-are-my-libraries",
    "title": "Tutorial: Designing de novo variant libraries using PoET",
    "section": "How good are my libraries?",
    "text": "How good are my libraries?\nTo evaluate Prot2prot, we can take a look at how well Prot2prot’s likelihood scores correlate with actual activity measurements. If Prot2prot’s scores are predictive, this gives us confidence that the model has learned the underlying generative process and will be able to generate a good library.\n\n\n\n\n\n\nHow is it that PoET scores can be predictive of function despite having never seen functional measurements?\n\n\n\nAn excellent question! Well, it turns out that evolution has already done a lot of the work for us, and that there is a lot to learn from naturally occurring sequences. In fact, our experiments show that even though PoET does not use any measurement information, PoET scores correlate with functional measurements across diverse tasks in a wide variety of datasets. You can read more about these experiments in our upcoming preprint.\n\n\nLet’s evaluate Prot2prot’s scores against actual activity measurements for chorismate mutase. We will be using a dataset of artificial variant sequences of chorismate mutase that were designed by Russ et al. (2020). In their work, Russ et al. designed these variant sequences using an evolutionary generative model, and then measured their catalytic activity.\nTo evaluate query sequences against a given MSA, we can use the Create query tool.\n\n\n\nFirst, provide the set of variant sequences that you wish score as the query input. The app expects the input in the form of a headerless csv file with the sequences in the first column. You can either download the raw data from supplementary table 2 in the paper and munge it yourself, or use the pre-formatted version provided here. Note that the activity measurement column is the last column (“norm r.e.”). This is the normalized relative enrichment score that measures chorismate mutase catalytic activity as reported by their assay.\nhttps://drive.google.com/uc?export=download&id=1vYIjxEq_JUSwgkAcpAED9kzTvi_8euzu\n\n\n\nUpload variant sequences as query input\n\n\nNext, set as the prompt definition the sequence encoding chorismate mutase in E. coli. Check the box to use this sequence to automatically build the MSA. We will also set the number of prompts to ensemble to 3.\n&gt;E. coli chorismate mutase\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDI\nDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n\n\n\n\n\n\nNote\n\n\n\nEnsembling more prompts improves prediction performance and reduces stochasticity from the prompt sampling. However, increasing the ensemble number has diminishing returns, while also taking longer to run. In general, we recommend using 3-5.\n\n\n\n\n\nSet the prompt definition\n\n\nNow click run, and voila! After a few moments, we can review the predicted scores in the Result tab.\nComparing the PoET likelihood scores to the measured chorismate mutase activity, we find that PoET is extremely predictive (r = 0.522, left) even without having seen any functional measurements. This gives us confidence that high-scoring sequences generated by PoET are good candidates for testing in downstream assays.\n\n\n\nWhen we compare PoET performance against the evolutionary model by Russ et al. (right, r = 0.436), we even find that PoET performs better!\n\n\n\n\n\n\nPoET: A model for all proteins\n\n\n\nIn their work, Russ et al. fit a model that scores and generates sequences specifically for the chorismate mutase family.\nPoET generalizes to all families, meaning that in just a few clicks, you can score and generate sequences not only for chorismate mutase, but also for any protein family you are interested in, simply by defining a suitable prompt!"
  },
  {
    "objectID": "api-embeddings.html",
    "href": "api-embeddings.html",
    "title": "Embeddings",
    "section": "",
    "text": "Endpoints to calculate embeddings for protein sequences."
  },
  {
    "objectID": "api-embeddings.html#endpoints",
    "href": "api-embeddings.html#endpoints",
    "title": "Embeddings",
    "section": "",
    "text": "Endpoints to calculate embeddings for protein sequences."
  },
  {
    "objectID": "api-embeddings.html#apiv1",
    "href": "api-embeddings.html#apiv1",
    "title": "Embeddings",
    "section": "/api/v1/",
    "text": "/api/v1/"
  },
  {
    "objectID": "models-page.html",
    "href": "models-page.html",
    "title": "Training model(s)",
    "section": "",
    "text": "On the ‘Dataset’ tab, click on ‘Start training’. You can name your model and select which properties you want to be able to predict. We’ll call our model “Model” and fit it for all three properties here.\n\n\n\nAfter model training is complete, the app will automatically evaluate the predictive performance using cross-validation. To view the training curves and cross-validation results, navigate to the “Diagnostics” tab.\nCross-validation is a reliable method to estimate the expected performance of the models in predicting properties for new variants. The app splits your variants into 5-folds, trains the model on four folds, and predicts the held-out fold. The cross-validation plots display the predicted properties versus the actual measured properties for each held-out variant.\nWhat does it mean: A high correlation between the predicted and ground truth values suggests that the models can accurately predict the substrate activity for new sequence variants."
  },
  {
    "objectID": "visualizations-page.html",
    "href": "visualizations-page.html",
    "title": "Visualizations",
    "section": "",
    "text": "OpenProtein offers a suite of visualizations which also allows customizations:"
  },
  {
    "objectID": "visualizations-page.html#umap",
    "href": "visualizations-page.html#umap",
    "title": "Visualizations",
    "section": "UMAP",
    "text": "UMAP\nThe UMAP creates a 2D visualization of the manifold of your sequence variants, using a low-dimensional embedding technique to represent each variant sequence in two dimensions based on their similarities in the high-dimensional feature space. Each point in the visualization represents a single sequence variant.\n\nThe points are colored by their corresponding property values in your dataset. The “UMAP options” panel allows you to change the color scheme, reverse the color scheme, and toggle between multiple properties."
  },
  {
    "objectID": "visualizations-page.html#joint-plot",
    "href": "visualizations-page.html#joint-plot",
    "title": "Visualizations",
    "section": "Joint plot",
    "text": "Joint plot\nYou can explore your dataset by selecting properties to view a joint plot that depicts the pairwise relationships between them. The joint plot provides a visual representation of the distribution of individuals of each variable and helps in understanding the relationship between two variables."
  },
  {
    "objectID": "job-status-page.html",
    "href": "job-status-page.html",
    "title": "Job Status",
    "section": "",
    "text": "View the status of your Prediction and Design jobs in the jobs panel on the right side of the page. Upon submitting jobs, you may navigate away from the page. You may access the results through this panel."
  },
  {
    "objectID": "poet-introduction-page.html",
    "href": "poet-introduction-page.html",
    "title": "Introduction to PoET",
    "section": "",
    "text": "PoET is a generative protein language model that allows controllable design of protein sequences and variant effect prediction. This model is controlled by providing it with a prompt, a set of sequences that represent homologues, family members, or some other grouping of related sequences that represent your protein of interest. We provide tools for creating these prompts from multiple sequence alignments (MSAs) and for using homology search to build MSAs from a seed sequence.\nGiven a prompt, you can"
  },
  {
    "objectID": "poet-introduction-page.html#accessing-poet",
    "href": "poet-introduction-page.html#accessing-poet",
    "title": "Introduction to PoET",
    "section": "Accessing PoET",
    "text": "Accessing PoET\n\n\n\nPoET tools can be found in the “PoET…” dropdown menu in the header bar of the OpenProtein.AI web app."
  },
  {
    "objectID": "poet-tools-page.html",
    "href": "poet-tools-page.html",
    "title": "PoET Tools",
    "section": "",
    "text": "Click “Create query” to go to the query tool. This tool allows you to score arbitrary sequences defined in a fasta or CSV file. It will calculate the log-likelihood of each sequence conditioned on the sequence context defined by the prompt.\n\nThis tool is useful if you want to score, prioritize, or rank specific sequence variants of interest. For example, you could score homologous sequences mined from a database, perform a synthetic alanine scan or deletion scan, or enumerate combinatorial mutations at specific sites.\nClicking “Run” will start the job. This could take a few minutes depending on how busy the service is, how long your sequences are, and how many sequences you want to score.\n\nThe results are presented as a table, which can be sorted and downloaded. You can further explore the local fitness landscape of each sequence by using the quick links to the ‘Single site analysis’ page. This will run single site analysis for the specified sequence with your prompt. You can also add new sequences to the job using the “Add sequences” button."
  },
  {
    "objectID": "poet-tools-page.html#scoring-sequences-with-poet",
    "href": "poet-tools-page.html#scoring-sequences-with-poet",
    "title": "PoET Tools",
    "section": "",
    "text": "Click “Create query” to go to the query tool. This tool allows you to score arbitrary sequences defined in a fasta or CSV file. It will calculate the log-likelihood of each sequence conditioned on the sequence context defined by the prompt.\n\nThis tool is useful if you want to score, prioritize, or rank specific sequence variants of interest. For example, you could score homologous sequences mined from a database, perform a synthetic alanine scan or deletion scan, or enumerate combinatorial mutations at specific sites.\nClicking “Run” will start the job. This could take a few minutes depending on how busy the service is, how long your sequences are, and how many sequences you want to score.\n\nThe results are presented as a table, which can be sorted and downloaded. You can further explore the local fitness landscape of each sequence by using the quick links to the ‘Single site analysis’ page. This will run single site analysis for the specified sequence with your prompt. You can also add new sequences to the job using the “Add sequences” button."
  },
  {
    "objectID": "poet-tools-page.html#single-site-analysis",
    "href": "poet-tools-page.html#single-site-analysis",
    "title": "PoET Tools",
    "section": "Single site analysis",
    "text": "Single site analysis\nClick “Single site analysis” to go to the single site analysis tool. This tool will score all single substitution variants of a parent sequence, conditioned on the prompt, and present the results in a heatmap.\n\nResults can be downloaded as a table using the “Export” button. The single site page will also show the highest scoring variants and sites in tables below the heatmap for quick reference. The parameters used to run the single site analysis can be found in the “Single site details” tab.\n\nClicking on a variant in the heatmap will open the “Run new” drawer and fill in that variant to provide a quick link to run single site analysis on that variant as the parent sequence using the same prompt. You can also enter an arbitrary sequence in “Run new” to run single site analysis for other sequences without respecifying the prompt.\n\nSingle site analysis is useful if you want to understand the local fitness landscape of a protein, identify promising single substitution variants, identify hotspots for mutagenesis, and design combinatorial variant libraries."
  },
  {
    "objectID": "poet-tools-page.html#generate-novel-sequences",
    "href": "poet-tools-page.html#generate-novel-sequences",
    "title": "PoET Tools",
    "section": "Generate novel sequences",
    "text": "Generate novel sequences\nClick “Generate sequences” to go to the sequence generation tool. This tool allows you to sample novel protein sequences conditioned on the sequence context provided by your prompt sequences. This tool offers a way to explore and efficiently generate functional sequences from the fitness landscape around your prompt sequences. Generate is ideal for designing high diversity, bespoke protein sequence libraries and can sample non-trivial and variable length sequences.\n\nThe sampling behaviour can be controlled by tuning your prompt and through the sampling options provided. In particular, “temperature,” “top-p,” and “top-k” provide the ability to focus sampling around highly likely sequences by adjusting these parameters.\nGenerated sequences are presented in a table similar to the Query results above.\n\nThe table can be downloaded using the “Export” button and local fitness landscapes are quickly accessible via the single site analysis buttons for each sequence."
  },
  {
    "objectID": "demo-datasets-page.html",
    "href": "demo-datasets-page.html",
    "title": "Demo datasets",
    "section": "",
    "text": "This dataset is a single mutation site saturating dataset from Wrenbeck, Azouz, and Whitehead (2017) containing activity measurements for enzyme variants against three different substrates. The parent sequence is AMIE_PSEAE (UniProt identifier P11436).\n6,819 entries with 3 properties. Download"
  },
  {
    "objectID": "demo-datasets-page.html#aliphatic-amidase-amie_pseae",
    "href": "demo-datasets-page.html#aliphatic-amidase-amie_pseae",
    "title": "Demo datasets",
    "section": "",
    "text": "This dataset is a single mutation site saturating dataset from Wrenbeck, Azouz, and Whitehead (2017) containing activity measurements for enzyme variants against three different substrates. The parent sequence is AMIE_PSEAE (UniProt identifier P11436).\n6,819 entries with 3 properties. Download"
  },
  {
    "objectID": "demo-datasets-page.html#antibody-heavy-chain-14h",
    "href": "demo-datasets-page.html#antibody-heavy-chain-14h",
    "title": "Demo datasets",
    "section": "Antibody heavy chain (14H)",
    "text": "Antibody heavy chain (14H)\nThis dataset contains binding affinity measurements to the target for a random mutagenesis library containing single, double, and triple mutants of an antibody heavy chain variable region from Li et al. (2022). Mutations were limited to CDRs 1, 2, and 3. Measurements are log base 10 of the binding Kd in nM.\n7,476 entries with 1 property. Download"
  },
  {
    "objectID": "demo-datasets-page.html#antibody-light-chain-14l",
    "href": "demo-datasets-page.html#antibody-light-chain-14l",
    "title": "Demo datasets",
    "section": "Antibody light chain (14L)",
    "text": "Antibody light chain (14L)\nThis dataset contains binding affinity measurements to the target for a random mutagenesis library containing single, double, and triple mutants of an antibody light chain variable region from Li et al. (2022). Mutations were limited to CDRs 1, 2, and 3. Measurements are log base 10 of the binding Kd in nM.\n14,339 entries with 1 property. Download"
  },
  {
    "objectID": "demo-datasets-page.html#aminoglycoside-3-phosphotransferase-kka2_klepn",
    "href": "demo-datasets-page.html#aminoglycoside-3-phosphotransferase-kka2_klepn",
    "title": "Demo datasets",
    "section": "Aminoglycoside 3'-phosphotransferase (KKA2_KLEPN)",
    "text": "Aminoglycoside 3'-phosphotransferase (KKA2_KLEPN)\nThis is a single mutation site saturating dataset from Melnikov et al. (2014). containing measurements of E. coli growth in the presence of six different antibiotics. This protein is a kinase that confers antibiotic resistance, hence, growth measures the activity of the kinase on these antibiotic substrates. The parent sequence is KKA2_KLEPN (UniProt identifier P00552)\n5,279 entries with 6 properties. Download"
  },
  {
    "objectID": "design-page.html",
    "href": "design-page.html",
    "title": "Creating your designs",
    "section": "",
    "text": "Under ‘Dataset on the left panel’, select your desired dataset and click on “Create a design”. This will take you to a new page where you can define your design objectives and then the platform will search for sequence variants most likely to achieve those objectives.\nTo explore tradeoffs between the number of mutations in each variant and predicted properties, choose the “Use number of mutations criteria” option and set criteria for multiple properties.\n\nThe design algorithm is set to run for 10 steps by default. However, to generate more candidate sequences and allow the algorithm more time to find potentially better variants, this number can be increased.\n\n\n\nAfter adjusting the settings, click “Generate design” to initiate the algorithm. The design will be saved and can be accessed from the navigation panel. Please note that the algorithm may take some time to complete, but you will be able to view the results as they are generated."
  },
  {
    "objectID": "design-page.html#running-the-design-tool",
    "href": "design-page.html#running-the-design-tool",
    "title": "Creating your designs",
    "section": "",
    "text": "Under ‘Dataset on the left panel’, select your desired dataset and click on “Create a design”. This will take you to a new page where you can define your design objectives and then the platform will search for sequence variants most likely to achieve those objectives.\nTo explore tradeoffs between the number of mutations in each variant and predicted properties, choose the “Use number of mutations criteria” option and set criteria for multiple properties.\n\nThe design algorithm is set to run for 10 steps by default. However, to generate more candidate sequences and allow the algorithm more time to find potentially better variants, this number can be increased.\n\n\n\nAfter adjusting the settings, click “Generate design” to initiate the algorithm. The design will be saved and can be accessed from the navigation panel. Please note that the algorithm may take some time to complete, but you will be able to view the results as they are generated."
  },
  {
    "objectID": "design-page.html#design-criteria",
    "href": "design-page.html#design-criteria",
    "title": "Creating your designs",
    "section": "Design Criteria",
    "text": "Design Criteria\nProperty predictors in OpenProtein.AI are Bayesian. They output a distribution over possible values of the property for a variant. The mean is what you would get from a typical regression model, but our models also output a standard deviation which indicates how certain we are in the value of that property. Based on this distribution, we can calculate the probability that a sequence variant meets some design goal defined by the property value being greater than or less than some target value. This is how our design criteria are defined. The score given by the predictive models is the log probability that the sequence meets the defined design criteria.\nThis means that it is important to set reasonable target values for your design criteria, because it has a direct impact on the behaviour of the search algorithm. If the target value is set too ambitiously, then the algorithm will favor exploration by proposing variants with high uncertainty. Why? Because no variant will have expected property value at or beyond the target value, so variants with high uncertainties will be more likely to achieve the design criteria than sequences with low uncertainties. In other words, the model is certain that those variants will not achieve the design objective and it will explore high uncertainty variants instead. This will generally cause the algorithm to explore variants more distant from your mutagenesis dataset."
  },
  {
    "objectID": "design-page.html#examining-design-results",
    "href": "design-page.html#examining-design-results",
    "title": "Creating your designs",
    "section": "Examining design results",
    "text": "Examining design results\nThis article details the suite of visualizations methods available on the platform\n\nUMAP\nOnce the algorithm finishes, you’ll see the variant sequences generated by the design process overlaid on the UMAP. To distinguish between variants, you can adjust the color settings and change the property the new points are colored by in the color options panel. The designed sequences are colored by predicted properties.\n\n\n\nHistogram\nYou can view histograms comparing the expected property distributions for the designs against your original library and joint plots for all of the properties in the “Histogram” and “Joint plot” tabs.\n\n\n\nJoint plots\nYou can view joint plots for all of the properties under the “Joint plot” tab.\n\nNote that the design table will show all sequences, not just the best ones.\nBelow the plots, you can see the table of the generated sequences. The design algorithm may not generate all unique sequences at every step, so you can filter the table to only show unique sequences using the option in “Advanced filters.” You can sort the sequences by predicted property and the score assigned to each according to your design criteria. For score, larger (closer to zero) is better.\n\nThe filter icon next to each column name also allows you to set simple filters that can be applied to the designs."
  },
  {
    "objectID": "design-page.html#exporting-results",
    "href": "design-page.html#exporting-results",
    "title": "Creating your designs",
    "section": "Exporting results",
    "text": "Exporting results\nThe design table can be downloaded as a CSV to work with in other software using the “Export…” button. You can choose to download the whole table or only your currently filtered rows."
  },
  {
    "objectID": "introduction-page.html",
    "href": "introduction-page.html",
    "title": "Introduction to OpenProtein",
    "section": "",
    "text": "This article includes a high-level summary of core features, along with links to explore more documentation for each area."
  },
  {
    "objectID": "introduction-page.html#projects",
    "href": "introduction-page.html#projects",
    "title": "Introduction to OpenProtein",
    "section": "Projects",
    "text": "Projects\nThis is the overall folder where your datasets, designs and libraries will be housed in. You can create more than 1 project. Learn more about projects."
  },
  {
    "objectID": "introduction-page.html#datasets",
    "href": "introduction-page.html#datasets",
    "title": "Introduction to OpenProtein",
    "section": "Datasets",
    "text": "Datasets\nOnce you have uploaded your datasets, you will be able to view them here. Our system automatically creates a UMAP, joint plot and histogram. You will be able to upload multiple datasets. Learn more about uploading your datasets."
  },
  {
    "objectID": "introduction-page.html#designs",
    "href": "introduction-page.html#designs",
    "title": "Introduction to OpenProtein",
    "section": "Designs",
    "text": "Designs\nThe design module allows you to create the best base sequences based on specific properties. Once you have run the design tool, you can find your optimized sequences in this module. Learn more about Design"
  },
  {
    "objectID": "introduction-page.html#libraries",
    "href": "introduction-page.html#libraries",
    "title": "Introduction to OpenProtein",
    "section": "Libraries",
    "text": "Libraries\nThe Libraries module allows you to store your design sequences for easy reference. Learn more about Libraries."
  },
  {
    "objectID": "poet-defining-prompts-page.html",
    "href": "poet-defining-prompts-page.html",
    "title": "Using PoET",
    "section": "",
    "text": "The prompt defines the target sequence distribution. It provides the PoET model with information about sequence constraints, local fitness landscape, and co-evolutionary patterns, from which PoET will infer a generative model over protein sequences. The prompt definition tools allow you to specify and control what sequences are used to define this generative context.\nThe primary way to define a prompt is to provide a seed sequence, which could be your parent sequence, or some other sequence representing the space of proteins within which you would like to sample or explore.\nTo use this option, check the “Use first sequence as seed to generate MSA” box. The seed sequence will then be used to build out a multiple sequence alignment of naturally occurring homologous sequences from which the prompt sequences will be randomly selected. You may also provide your own set of homologous sequences as an MSA, from which the prompt will be created.\nNote: if you provide your own MSA, the system will consider the first sequence as the seed sequence.\nThis sampling process is controlled by the sampling strategy, homology level, and maximum and minimum similarity parameters. These are set to reasonable values by default, which we have found to perform well across a wide range of protein families. These can be tuned, however, to control the diversity of sequences that will be modeled by PoET.\n\n\n\n\n\n\nDescriptions\n\n\n\nSampling strategy - this parameter defines the sampling strategy used for selecting prompt sequences from the homologues found by homology search, or from the provided MSA. We recommend using the default “Neighbors” method.\nHomology level - this parameter controls the identity level at which two sequences are considered “neighbors” - that is, redundant - in the MSA. This is equivalent to the homology level used to calculate the number of effective sequences in protein families.\nMaximum similarity - the maximum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity greater than this to the seed will be included.\nMinimum similarity - the minimum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity less than this to the seed will be included. This is useful for creating prompts that are highly focused on the local sequence space around the seed.\n\n\nIf your protein comes from a highly diverse family or you wish to explore a large and diverse set of variants, then adjusting the homology level to be lower will select higher diversity prompt sequences and thus generate higher diversity sequence distributions. On the other hand, if you wish to have more focused generation, then using a higher homology level and setting a minimum similarity threshold can help to ensure that the prompt focuses on the local sequence landscape around your seed.\nEnsembling - instead of using a single prompt, multiple randomly sampled prompts can be used together by ensembling. We’ve found that this consistently improves performance when predicting variant effects by a small amount, but it will also make predictions and sampling take more time. To build an ensemble prompt, set the number of prompts to ensemble to a number &gt;1. Three to five are generally enough, but we allow up to 15 prompts to be ensemble. There are diminishing returns to adding more prompts to the ensemble."
  },
  {
    "objectID": "poet-defining-prompts-page.html#defining-the-prompt",
    "href": "poet-defining-prompts-page.html#defining-the-prompt",
    "title": "Using PoET",
    "section": "",
    "text": "The prompt defines the target sequence distribution. It provides the PoET model with information about sequence constraints, local fitness landscape, and co-evolutionary patterns, from which PoET will infer a generative model over protein sequences. The prompt definition tools allow you to specify and control what sequences are used to define this generative context.\nThe primary way to define a prompt is to provide a seed sequence, which could be your parent sequence, or some other sequence representing the space of proteins within which you would like to sample or explore.\nTo use this option, check the “Use first sequence as seed to generate MSA” box. The seed sequence will then be used to build out a multiple sequence alignment of naturally occurring homologous sequences from which the prompt sequences will be randomly selected. You may also provide your own set of homologous sequences as an MSA, from which the prompt will be created.\nNote: if you provide your own MSA, the system will consider the first sequence as the seed sequence.\nThis sampling process is controlled by the sampling strategy, homology level, and maximum and minimum similarity parameters. These are set to reasonable values by default, which we have found to perform well across a wide range of protein families. These can be tuned, however, to control the diversity of sequences that will be modeled by PoET.\n\n\n\n\n\n\nDescriptions\n\n\n\nSampling strategy - this parameter defines the sampling strategy used for selecting prompt sequences from the homologues found by homology search, or from the provided MSA. We recommend using the default “Neighbors” method.\nHomology level - this parameter controls the identity level at which two sequences are considered “neighbors” - that is, redundant - in the MSA. This is equivalent to the homology level used to calculate the number of effective sequences in protein families.\nMaximum similarity - the maximum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity greater than this to the seed will be included.\nMinimum similarity - the minimum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity less than this to the seed will be included. This is useful for creating prompts that are highly focused on the local sequence space around the seed.\n\n\nIf your protein comes from a highly diverse family or you wish to explore a large and diverse set of variants, then adjusting the homology level to be lower will select higher diversity prompt sequences and thus generate higher diversity sequence distributions. On the other hand, if you wish to have more focused generation, then using a higher homology level and setting a minimum similarity threshold can help to ensure that the prompt focuses on the local sequence landscape around your seed.\nEnsembling - instead of using a single prompt, multiple randomly sampled prompts can be used together by ensembling. We’ve found that this consistently improves performance when predicting variant effects by a small amount, but it will also make predictions and sampling take more time. To build an ensemble prompt, set the number of prompts to ensemble to a number &gt;1. Three to five are generally enough, but we allow up to 15 prompts to be ensemble. There are diminishing returns to adding more prompts to the ensemble."
  },
  {
    "objectID": "poet-defining-prompts-page.html#history",
    "href": "poet-defining-prompts-page.html#history",
    "title": "Using PoET",
    "section": "History",
    "text": "History\n\nThe PoET history page allows you to view and access past jobs, sorted by created date, job type, and status. Clicking the job ID will take you to the results page for that job. It also provides quick access to the specific PoET tools in the bottom bar: * Create query * single site analysis * generate sequences."
  },
  {
    "objectID": "poet-defining-prompts-page.html#scoring-sequences-with-poet",
    "href": "poet-defining-prompts-page.html#scoring-sequences-with-poet",
    "title": "Using PoET",
    "section": "Scoring sequences with PoET",
    "text": "Scoring sequences with PoET\nClick “Create query” to go to the query tool. This tool allows you to score arbitrary sequences defined in a fasta or CSV file. It will calculate the log-likelihood of each sequence conditioned on the sequence context defined by the prompt.\n\nThis tool is useful if you want to score, prioritize, or rank specific sequence variants of interest. For example, you could score homologous sequences mined from a database, perform a synthetic alanine scan or deletion scan, or enumerate combinatorial mutations at specific sites.\nClicking “run” will start the job. This could take a few minutes depending on how busy the service is, how long your sequences are, and how many sequences you want to score.\n\nThe results are presented as a table, which can be sorted and downloaded. You can further explore the local fitness landscape of each sequence by using the quick links to the Single site analysis page. This will run single site analysis for the specified sequence with your prompt. You can also add new sequences to the job using the “Add sequences” button."
  },
  {
    "objectID": "api-project.html",
    "href": "api-project.html",
    "title": "Project",
    "section": "",
    "text": "Endpoints to upload your dataset to OpenProtein’s engineering platform for train, predict and evaluate tasks. See the User Guide. Format your data as 2 column CSV:\n\nThe full sequence of each variant (mutation codes are also accepted)\n1+ columns with your measured properties (missing values are acceptable)\n\n\n\n\nEndpoints to train a model(s) on your measured properties to enable predictions for new sequences! See the User Guide. These workflows will additionally perform cross-validation on your models to estimate uncertainty. Note: A trained model is required before you can utilize predict or design endpoints.\n\n\n\nEndpoints for predicting properties on arbitary sequences with your OpenProtein trained models! Please see the User Guide. You can make predictions for single sequences as well as single mutant variants of the sequence. Note that you must first train a model with the train endpoints (see above).\n\n\n\nEndpoints to design new sequences based on your stated objectives and our genetic algorithm! See the User Guide. Note that these endpoints require you to first upload your datasets via assaydata endpoints. You may also require trained models from the train endpoints for full utility.\n\n\n\nEndpoints to create umap visualizations of embeddings!\n\n\n\nEndpoints to calculate embeddings for protein sequences.\n\n\n\nEndpoints to query job status for asynchronous jobs."
  },
  {
    "objectID": "api-project.html#endpoints",
    "href": "api-project.html#endpoints",
    "title": "Project",
    "section": "",
    "text": "Endpoints to upload your dataset to OpenProtein’s engineering platform for train, predict and evaluate tasks. See the User Guide. Format your data as 2 column CSV:\n\nThe full sequence of each variant (mutation codes are also accepted)\n1+ columns with your measured properties (missing values are acceptable)\n\n\n\n\nEndpoints to train a model(s) on your measured properties to enable predictions for new sequences! See the User Guide. These workflows will additionally perform cross-validation on your models to estimate uncertainty. Note: A trained model is required before you can utilize predict or design endpoints.\n\n\n\nEndpoints for predicting properties on arbitary sequences with your OpenProtein trained models! Please see the User Guide. You can make predictions for single sequences as well as single mutant variants of the sequence. Note that you must first train a model with the train endpoints (see above).\n\n\n\nEndpoints to design new sequences based on your stated objectives and our genetic algorithm! See the User Guide. Note that these endpoints require you to first upload your datasets via assaydata endpoints. You may also require trained models from the train endpoints for full utility.\n\n\n\nEndpoints to create umap visualizations of embeddings!\n\n\n\nEndpoints to calculate embeddings for protein sequences.\n\n\n\nEndpoints to query job status for asynchronous jobs."
  },
  {
    "objectID": "api-project.html#apiv1",
    "href": "api-project.html#apiv1",
    "title": "Project",
    "section": "/api/v1/",
    "text": "/api/v1/"
  }
]