[
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html",
    "href": "prots2prot/p2p_chorismate_mutase.html",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "Prots2prot is a generative protein language model that allows you to design protein sequences de novo, without functional measurements of your protein of interest. This means that you can use the model to generate single substitution, combinatorial variant libraries, or a bespoke high-diversity library, prior to making any measurements.\nProts2prot controls sequence generation via a prompt, which is defined as a set of sequences that encodes information about the local fitness landscape and co-evolutionary patterns of your given protein of interest. One way to build this prompt is by using a multiple sequence alignment (MSA) of your protein of interest using sequences across evolutionary lineages. Because these sequences share an evolutionary relationship, they contain information about the local fitness landscape of the protein. Prots2prot is able to infer the evolutionary process driving the generation of these sequences, and hence not only sample new sequences, but also score the likelihood of seeing a given sequence under this process.\nChorismate mutase is a important enzyme involved in the biosynthesis of aromatic amino acids. Specifically, it catalyzes the conversion of chorismate to prephenate. In this tutorial, we will use Prots2prot to generate a prospective de novo variant library for chorismate mutase.\n\n\nTo generate single-substitution libraries, we can use the Single site analysis prediction tool. This tool generates and scores all single-substitution variants of the given query sequence.\n\n\n\nFirst, define the query sequence for which we wish to generate all single substutions.\nNext, define the prompt. Recall that this is a set of sequences that implicitly describe the local fitness landscape of your protein of interest. The easiest way to do this is to paste the same query sequence and simply ask the tool to automatically generate the MSA from it. Here, our query sequence is the sequence encoding chorismate mutase in E. coli.\n\n\n\nInput query sequence\n\n\nAlternatively, if you already have an MSA or some other set of sequences that you wish to use as the prompt, you can also drop or select your own file.\n\n\n\nInput custom prompt\n\n\nAnd that’s all we need for the analysis! Click Run at the bottom of the page to generate and score all single site variant libraries. There are several other advanced options that we may want to play with after our initial run. However, the default options have been tuned to generate a reasonable starter library.\nWhen the run is complete, navigate to the Results tab to inspect the output of the run. At the top of the page is a summary detailing the score for the query sequence, as well as the number of sites and number of variants expected to improve over the input. The full results are presented as a heatmap, which you can mouse over for more detail. For convenience, the tables at the bottom of the page list the top 5 variants and sites.\n:bulb: The score assigned by Prots2prot is the log likelihood of the sequence under the model. This means that the larger (less negative) the score, the higher the probability of observing the sequence given the model.\nAs we can see, position 40 seems like a promising candidate for mutagenesis, with many mutations such as L&gt;D, L&gt;E and L&gt;A all improving over the query sequence.\n\n\n\nResults\n\n\nThe full results are available for export either as a csv or as a png. To do so, you can use the export button located at the top right hand corner of the page. Alternatively, you can also start a new single-site run against the same prompt either by selecting a particular variant sequence in the heatmap or in the table. Then, start a new single site analysis using Run new....\n\n\n\nExport\n\n\nCongratulations! :tada: You have now created your first de novo variant library using Prots2prot!\n\n\n\nTODO\n\n\n\nWhy should we care about generating high-diversity libraries? The typical strategy in protein engineering is to search the local sequence space near a known sequence by generating single and combinatorial variant libraries. However, this may not be the best strategy for several reasons:\n\nYou may not have a good starting sequence. In this case, you will want to cast your net as wide as possible by sampling a variety of stable and functional proteins. However, you still don’t want to be generating biologically impossible proteins.\nYou started with an ok sequence, but are stuck in a local optima. This means that there may be distant sequences that have even higher activity. However, these either cannot be found via a simple greedy optimization strategy, or may take an unreasonable number of steps to reach it.\n\n\n\n\nThis greedy algorithm is going in the direction of the best local improvementbut is actually moving further away from the global peak.\n\n\n\nYou want to hedge your bets. Unfortunately, similar sequences are likely to share other possibly unwanted, but correlated properties. For example, a set of similar sequences may all have high activity but may also all be unstable or poorly expressed. Just as with investing, it is good to diversity your portfolio.\n\nTo generate high-diversity libraries, we can use the Generate sequences tool.\n\n\n\nAs in the single-site analysis tool, we have to specify the prompt. We will again use the sequence for chorismate mutase in E. coli. to seed the MSA. Since chorismate mutase is a relatively short protein, we will set the maximum generated protein length to 200. We also set the number of sequences to generate to 100. Hitting run then dispatches the generate job.\n\n\n\nGenerate sequences\n\n\nThe results of the tool are returned in the Results tab as a table. Recall that the larger (less negative) the score, the higher the likelihood of the sequence under the model. We can use the table widget to filter our sequences to have some minimum score, and then export them for further analysis.\n\n\n\nFilter sequences\n\n\nHowever, looking at the table, we can already observe that only 1 sequence has a score higher than the original query sequence that we input in the original analysis. To generate more highly-scoring sequences, we might want to lower Top-p, which reduces the randomness of the sampling by only sampling from the top most likely amino acids up to the specified cumulative frequency. We can also lower the temperature, which emphasizes higher probability amino acids during sampling by raising the probability to the power of the temperature.\nLet’s try setting Top-p to 0.9! Here we can see that there are a lot more high-scoring sequences.\n\n\n\nFilter sequences\n\n\n:bulb: Hover the tooltips to learn about how the different parameters affect the results! Although we have set reasonable defaults for many of these parameters, we recommend that you also try playing around with them to customize your libraries.\n\n\n\nTo evaluate Prot2prot, we can take a look at how well Prot2prot’s scores predict actual activity measurements. If Prot2prot’s scores are predictive, this gives us confidence that the model has learned the underlying generative process and will be able to generate a good library.\n:bulb: How is it that Prots2prot scores can be predictive of function despite having never seen functional measurements? An excellent question! Well, it turns out that evolution has already done a lot of the work for us, and that there is a lot to learn from naturally occurring sequences. In fact, our experiments show that even though Prots2prot does not use any measurement information, Prots2prot scores correlate with functional measurements across diverse tasks in a wide variety of datasets. You can read more about these experiments in our upcoming preprint.\nLet’s evaluate Prot2prot’s scores against actual activity measurements for a high diversity variant library of chorismate mutase!\nTo evaluate query sequences against a given MSA, we can use the Create query tool.\n\n\n\n\n\n\nWe can also use Prot2prot to prioritize variants in an existing library."
  },
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html#generating-single-substitution-libraries",
    "href": "prots2prot/p2p_chorismate_mutase.html#generating-single-substitution-libraries",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "To generate single-substitution libraries, we can use the Single site analysis prediction tool. This tool generates and scores all single-substitution variants of the given query sequence.\n\n\n\nFirst, define the query sequence for which we wish to generate all single substutions.\nNext, define the prompt. Recall that this is a set of sequences that implicitly describe the local fitness landscape of your protein of interest. The easiest way to do this is to paste the same query sequence and simply ask the tool to automatically generate the MSA from it. Here, our query sequence is the sequence encoding chorismate mutase in E. coli.\n\n\n\nInput query sequence\n\n\nAlternatively, if you already have an MSA or some other set of sequences that you wish to use as the prompt, you can also drop or select your own file.\n\n\n\nInput custom prompt\n\n\nAnd that’s all we need for the analysis! Click Run at the bottom of the page to generate and score all single site variant libraries. There are several other advanced options that we may want to play with after our initial run. However, the default options have been tuned to generate a reasonable starter library.\nWhen the run is complete, navigate to the Results tab to inspect the output of the run. At the top of the page is a summary detailing the score for the query sequence, as well as the number of sites and number of variants expected to improve over the input. The full results are presented as a heatmap, which you can mouse over for more detail. For convenience, the tables at the bottom of the page list the top 5 variants and sites.\n:bulb: The score assigned by Prots2prot is the log likelihood of the sequence under the model. This means that the larger (less negative) the score, the higher the probability of observing the sequence given the model.\nAs we can see, position 40 seems like a promising candidate for mutagenesis, with many mutations such as L&gt;D, L&gt;E and L&gt;A all improving over the query sequence.\n\n\n\nResults\n\n\nThe full results are available for export either as a csv or as a png. To do so, you can use the export button located at the top right hand corner of the page. Alternatively, you can also start a new single-site run against the same prompt either by selecting a particular variant sequence in the heatmap or in the table. Then, start a new single site analysis using Run new....\n\n\n\nExport\n\n\nCongratulations! :tada: You have now created your first de novo variant library using Prots2prot!"
  },
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html#generating-combinatorial-variant-libraries",
    "href": "prots2prot/p2p_chorismate_mutase.html#generating-combinatorial-variant-libraries",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html#generating-high-diversity-libraries",
    "href": "prots2prot/p2p_chorismate_mutase.html#generating-high-diversity-libraries",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "Why should we care about generating high-diversity libraries? The typical strategy in protein engineering is to search the local sequence space near a known sequence by generating single and combinatorial variant libraries. However, this may not be the best strategy for several reasons:\n\nYou may not have a good starting sequence. In this case, you will want to cast your net as wide as possible by sampling a variety of stable and functional proteins. However, you still don’t want to be generating biologically impossible proteins.\nYou started with an ok sequence, but are stuck in a local optima. This means that there may be distant sequences that have even higher activity. However, these either cannot be found via a simple greedy optimization strategy, or may take an unreasonable number of steps to reach it.\n\n\n\n\nThis greedy algorithm is going in the direction of the best local improvementbut is actually moving further away from the global peak.\n\n\n\nYou want to hedge your bets. Unfortunately, similar sequences are likely to share other possibly unwanted, but correlated properties. For example, a set of similar sequences may all have high activity but may also all be unstable or poorly expressed. Just as with investing, it is good to diversity your portfolio.\n\nTo generate high-diversity libraries, we can use the Generate sequences tool.\n\n\n\nAs in the single-site analysis tool, we have to specify the prompt. We will again use the sequence for chorismate mutase in E. coli. to seed the MSA. Since chorismate mutase is a relatively short protein, we will set the maximum generated protein length to 200. We also set the number of sequences to generate to 100. Hitting run then dispatches the generate job.\n\n\n\nGenerate sequences\n\n\nThe results of the tool are returned in the Results tab as a table. Recall that the larger (less negative) the score, the higher the likelihood of the sequence under the model. We can use the table widget to filter our sequences to have some minimum score, and then export them for further analysis.\n\n\n\nFilter sequences\n\n\nHowever, looking at the table, we can already observe that only 1 sequence has a score higher than the original query sequence that we input in the original analysis. To generate more highly-scoring sequences, we might want to lower Top-p, which reduces the randomness of the sampling by only sampling from the top most likely amino acids up to the specified cumulative frequency. We can also lower the temperature, which emphasizes higher probability amino acids during sampling by raising the probability to the power of the temperature.\nLet’s try setting Top-p to 0.9! Here we can see that there are a lot more high-scoring sequences.\n\n\n\nFilter sequences\n\n\n:bulb: Hover the tooltips to learn about how the different parameters affect the results! Although we have set reasonable defaults for many of these parameters, we recommend that you also try playing around with them to customize your libraries."
  },
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html#how-good-are-my-libraries",
    "href": "prots2prot/p2p_chorismate_mutase.html#how-good-are-my-libraries",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "To evaluate Prot2prot, we can take a look at how well Prot2prot’s scores predict actual activity measurements. If Prot2prot’s scores are predictive, this gives us confidence that the model has learned the underlying generative process and will be able to generate a good library.\n:bulb: How is it that Prots2prot scores can be predictive of function despite having never seen functional measurements? An excellent question! Well, it turns out that evolution has already done a lot of the work for us, and that there is a lot to learn from naturally occurring sequences. In fact, our experiments show that even though Prots2prot does not use any measurement information, Prots2prot scores correlate with functional measurements across diverse tasks in a wide variety of datasets. You can read more about these experiments in our upcoming preprint.\nLet’s evaluate Prot2prot’s scores against actual activity measurements for a high diversity variant library of chorismate mutase!\nTo evaluate query sequences against a given MSA, we can use the Create query tool."
  },
  {
    "objectID": "prots2prot/p2p_chorismate_mutase.html#prioritizing-variants-in-an-existing-library",
    "href": "prots2prot/p2p_chorismate_mutase.html#prioritizing-variants-in-an-existing-library",
    "title": "Tutorial: Designing de novo variant libraries using Prots2prot",
    "section": "",
    "text": "We can also use Prot2prot to prioritize variants in an existing library."
  },
  {
    "objectID": "04_p2p_chorismate_case_study.html",
    "href": "04_p2p_chorismate_case_study.html",
    "title": "Connect to the OpenProtein.AI API",
    "section": "",
    "text": "%matplotlib inline\nimport numpy as np\nimport pandas as pd\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport scipy\nfrom scipy.stats import pearsonr,spearmanr,kendalltau\nimport json\nimport time\nimport openprotein\nimport openprotein.fasta as fasta\nwith open('secrets.config', 'r') as f:\n    config = json.load(f)\n\nsession = openprotein.connect(config['username'], config['password'])\nprint(session.backend)\n\nBackend.PROD"
  },
  {
    "objectID": "04_p2p_chorismate_case_study.html#load-the-chorismate-mutase-dataset",
    "href": "04_p2p_chorismate_case_study.html#load-the-chorismate-mutase-dataset",
    "title": "Connect to the OpenProtein.AI API",
    "section": "Load the chorismate mutase dataset",
    "text": "Load the chorismate mutase dataset\n\ntable_natural = pd.read_csv('data/chorismate_mutase_natural_sequences.csv')\ntable_variant = pd.read_csv('data/chorismate_mutase_variant_sequences.csv')\n\ntable_natural.head()\n\n\n\n\n\n\n\n\nNo.\nSpecies\nSequence\nID to EcCM\ntop ID\nEDCA (rel. to EcCM)\nnorm r.e.\n\n\n\n\n0\n1\nEscherichia coli ...\n-TSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPV...\n1.00\n0.93\n0.00\n1.00\n\n\n1\n2\nThermus thermophilus HB8 ...\n---DERIQALRKEVDRVNREILRLLSERGRLVQEIGRLQTELGLPH...\n0.26\n0.89\n28.62\n-0.06\n\n\n2\n3\nPseudomonas aeruginosa UCBPP-PA14 ...\nPEDCTGLADIREAIDQIDLDIVQALGRRMDYVKAASRFKANEA-AI...\n0.20\n0.71\n-4.19\n0.04\n\n\n3\n4\nEnterobacter cloacae subsp. dissolvens SDM ...\n-TPENPLLDLRVKISALDEKLLALLAERRALAIEVGKAKLDSHRPV...\n0.93\n0.93\n8.57\n0.65\n\n\n4\n5\nThermus aquaticus Y51MC23 ...\n---DERIQALRREVDRVNRELLRLLSERGRLVQEIGRIQTELGLPH...\n0.28\n0.89\n18.42\n-0.08\n\n\n\n\n\n\n\n\ntable_variant.head()\n\n\n\n\n\n\n\n\nNo.\nT\nreg. value\nSequence\nID to EcCM\ntop ID\nEDCA (rel. to EcCM)\nnorm r.e.\n\n\n\n\n0\n1131\n0.33\n0.01\n--TDNPLLALRERISALDLKLLALLAERRALALEVARTKLASHRPI...\n0.78\n0.82\n-16.37\n0.85\n\n\n1\n1132\n0.33\n0.01\nLLVGLFFSTTALAAAIPSEDVASLINQRLSYMKDVAGYKANNHLAI...\n0.14\n0.84\n-0.39\n0.04\n\n\n2\n1133\n0.33\n0.01\nPEDCEGLADIRRGIDALDREIVQILGRRLGYVKAASQFKPSEQ--I...\n0.20\n0.73\n-3.03\n-0.02\n\n\n3\n1134\n0.33\n0.01\nPAAREELLELRGSIDNIDAALVHLLAERFKCTQRVGRLKARHGLPP...\n0.30\n0.81\n-9.73\n-0.11\n\n\n4\n1135\n0.33\n0.01\n----KKLEEYRKEIDEIDKEIIKLFEKRMDVVLKVIEYKKKNNMPI...\n0.18\n0.65\n0.70\n0.88\n\n\n\n\n\n\n\n\n_, axs = plt.subplots(1, 2, figsize=(12, 4), sharex=True, sharey=True)\naxs[0].scatter(table_natural['EDCA (rel. to EcCM)'].values, table_natural['norm r.e.'].values)\naxs[0].set_title('Natural')\naxs[1].scatter(table_variant['EDCA (rel. to EcCM)'].values, table_variant['norm r.e.'].values)\naxs[1].set_title('Variants')\n\nprint('Natural', spearmanr(table_natural['EDCA (rel. to EcCM)'].values, table_natural['norm r.e.'].values))\nprint('Variants', spearmanr(table_variant['EDCA (rel. to EcCM)'].values, table_variant['norm r.e.'].values))\n\nNatural SpearmanrResult(correlation=0.035330109128214444, pvalue=0.23534819924369454)\nVariants SpearmanrResult(correlation=-0.409259087679051, pvalue=2.2790178256876762e-66)\n\n\n\n\n\n\nx = np.concatenate([\n    table_natural['EDCA (rel. to EcCM)'].values,\n    table_variant['EDCA (rel. to EcCM)'].values,\n])\ny = np.concatenate([\n    table_natural['norm r.e.'].values,\n    table_variant['norm r.e.'].values,\n])\nplt.scatter(x, y)\nplt.title('All Sequences')\n\nprint('All', spearmanr(x, y))\n\nAll SpearmanrResult(correlation=-0.2746346565247013, pvalue=9.571166707058114e-49)\n\n\n\n\n\n\nUse EcCM (E. coli chorismate mutase) as the seed sequence\n\nseed = table_natural.iloc[0]['Sequence']\nseed = seed.replace('-', '')\nseed\n\n'TSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH'"
  },
  {
    "objectID": "04_p2p_chorismate_case_study.html#rank-the-natural-and-variant-sequences",
    "href": "04_p2p_chorismate_case_study.html#rank-the-natural-and-variant-sequences",
    "title": "Connect to the OpenProtein.AI API",
    "section": "Rank the natural and variant sequences",
    "text": "Rank the natural and variant sequences\n\nmsa = session.prots2prot.create_msa(seed.encode())\nprint(msa)\n\nprompt = session.prots2prot.sample_prompt(msa, num_ensemble_prompts=3, random_seed=42)\nprint(prompt)\n\nstatus=&lt;JobStatus.SUCCESS: 'SUCCESS'&gt; job_id='62c52db6-3ae2-4c90-9c14-533162a29dd1' job_type='workflow/align/align' created_date=datetime.datetime(2023, 5, 2, 10, 53, 8, 791528) start_date=None end_date=datetime.datetime(2023, 5, 2, 10, 53, 8, 812409) prerequisite_job_id=None progress_message=None progress_count=None msa_id='62c52db6-3ae2-4c90-9c14-533162a29dd1'\nstatus=&lt;JobStatus.SUCCESS: 'SUCCESS'&gt; job_id='99bdc24a-95e4-4bb9-995e-9ef10a6ca5ba' job_type='workflow/align/prompt' created_date=datetime.datetime(2023, 5, 2, 10, 53, 9, 162413) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None prompt_id='99bdc24a-95e4-4bb9-995e-9ef10a6ca5ba'\n\n\n\nsequences = table_natural['Sequence'].apply(lambda s: s.replace('-', '').encode()).values\nprint(sequences.shape)\n\nfuture_natural = session.prots2prot.score(prompt, sequences)\nprint(future_natural.job)\n\n(1130,)\nstatus=&lt;JobStatus.PENDING: 'PENDING'&gt; job_id='064cdcc3-a76c-4585-9813-264b4e31b44e' job_type='/workflow/prots2prot' created_date=datetime.datetime(2023, 5, 2, 10, 54, 17, 851821) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None parent_id=None s3prefix=None page_size=None page_offset=None num_rows=None result=None n_completed=None\n\n\n\nsequences = table_variant['Sequence'].apply(lambda s: s.replace('-', '').encode()).values\nprint(sequences.shape)\n\nfuture_variant = session.prots2prot.score(prompt, sequences)\nprint(future_variant.job)\n\n(1618,)\nstatus=&lt;JobStatus.PENDING: 'PENDING'&gt; job_id='956ee5a7-30c1-4272-8396-78f2f05f923a' job_type='/workflow/prots2prot' created_date=datetime.datetime(2023, 5, 2, 11, 35, 24, 779521) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None parent_id=None s3prefix=None page_size=None page_offset=None num_rows=None result=None n_completed=None\n\n\n\nresults_natural = future_natural.wait(verbose=True)\nresults_variant = future_variant.wait(verbose=True)\n\nprint(len(results_natural), len(results_variant))\n\n1it [00:00,  2.54it/s, status=SUCCESS]\n112it [05:18,  2.84s/it, status=SUCCESS]\n\n\n1130 1618\n\n\n\nscores_natural = np.array([r.score for r in results_natural])\nscores_variant = np.array([r.score for r in results_variant])\nscores_natural.shape, scores_variant.shape\n\n((1130, 3), (1618, 3))\n\n\n\nscore_natural = scores_natural.mean(axis=1)\nscore_variant = scores_variant.mean(axis=1)\nscore_natural.shape, scores_variant.shape\n\n((1130,), (1618, 3))\n\n\n\n_, axs = plt.subplots(1, 2, figsize=(12, 4))\n\nx = score_natural\ny = table_natural['norm r.e.'].values\naxs[0].scatter(x, y)\naxs[0].set_title('Natural')\nprint('Natural', spearmanr(x, y))\n\nx = score_variant\ny = table_variant['norm r.e.'].values\naxs[1].scatter(x, y)\naxs[1].set_title('Variant')\nprint('Variant', spearmanr(x, y))\n\nNatural SpearmanrResult(correlation=0.3482140322743968, pvalue=1.4801709792817108e-33)\nVariant SpearmanrResult(correlation=0.4967878271499042, pvalue=1.3965664362656567e-101)\n\n\n\n\n\n\nx = np.concatenate([\n    score_natural,\n    score_variant,\n])\ny = np.concatenate([\n    table_natural['norm r.e.'].values,\n    table_variant['norm r.e.'].values,\n])\nplt.scatter(x, y)\nplt.title('All Sequences')\n\nprint('All', spearmanr(x, y))\n\nAll SpearmanrResult(correlation=0.44488113678989877, pvalue=1.059566612055129e-133)"
  },
  {
    "objectID": "04_p2p_chorismate_case_study.html#what-if-we-use-the-functional-natural-sequences-as-the-prompt",
    "href": "04_p2p_chorismate_case_study.html#what-if-we-use-the-functional-natural-sequences-as-the-prompt",
    "title": "Connect to the OpenProtein.AI API",
    "section": "What if we use the functional natural sequences as the prompt?",
    "text": "What if we use the functional natural sequences as the prompt?\n\ntable_nat_functional = table_natural.loc[table_natural['norm r.e.'] &gt;= 0.45]\nprint(table_nat_functional.shape)\ntable_nat_functional.head()\n\n(407, 7)\n\n\n\n\n\n\n\n\n\nNo.\nSpecies\nSequence\nID to EcCM\ntop ID\nEDCA (rel. to EcCM)\nnorm r.e.\n\n\n\n\n0\n1\nEscherichia coli ...\n-TSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPV...\n1.00\n0.93\n0.00\n1.00\n\n\n3\n4\nEnterobacter cloacae subsp. dissolvens SDM ...\n-TPENPLLDLRVKISALDEKLLALLAERRALAIEVGKAKLDSHRPV...\n0.93\n0.93\n8.57\n0.65\n\n\n5\n6\nSalmonella enterica subsp. enterica serovar Sa...\n-TSENPLLALRDKISALDEELLALLAKRRALAIEVGQAKLLSHRPV...\n0.90\n0.89\n9.83\n0.70\n\n\n6\n7\nCronobacter sakazakii ATCC BAA-894 ...\n-TAENPLLALRDKISALDEQLLALLAQRRALAVEVGKAKLATHRPV...\n0.91\n0.90\n6.42\n0.95\n\n\n8\n9\nErwinia billingiae Eb661 ...\n-TPENPLLGLRDKISALDEQLLNMLAQRRALAIEVATAKMATHRPI...\n0.80\n0.85\n26.25\n0.84\n\n\n\n\n\n\n\n\nfrom io import BytesIO\n\nmsa_const = session.prots2prot.upload_msa(BytesIO(b'\\n'.join(table_nat_functional['Sequence'].apply(lambda s: s.encode()))))\nprint(msa_const)\n\nprompt_const = session.prots2prot.sample_prompt(msa_const, num_ensemble_prompts=3, random_seed=42)\nprint(prompt_const)\n\nstatus=&lt;JobStatus.SUCCESS: 'SUCCESS'&gt; job_id='b35fa25d-64e9-46e5-9b02-5cce2c1a6751' job_type='workflow/align/align' created_date=datetime.datetime(2023, 5, 2, 11, 48, 3, 691239) start_date=None end_date=datetime.datetime(2023, 5, 2, 11, 48, 3, 704917) prerequisite_job_id=None progress_message=None progress_count=None msa_id='b35fa25d-64e9-46e5-9b02-5cce2c1a6751'\nstatus=&lt;JobStatus.SUCCESS: 'SUCCESS'&gt; job_id='44218875-e55a-4285-99cf-1a1c95584959' job_type='workflow/align/prompt' created_date=datetime.datetime(2023, 5, 2, 11, 48, 4, 139727) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None prompt_id='44218875-e55a-4285-99cf-1a1c95584959'\n\n\n\nsequences = table_variant['Sequence'].apply(lambda s: s.replace('-', '').encode()).values\nprint(sequences.shape)\n\nfuture_variant_const = session.prots2prot.score(prompt_const, sequences)\nprint(future_variant_const.job)\n\n(1618,)\nstatus=&lt;JobStatus.PENDING: 'PENDING'&gt; job_id='29bc8f97-a508-49c3-8b97-a3b3150a4270' job_type='/workflow/prots2prot' created_date=datetime.datetime(2023, 5, 2, 11, 49, 5, 893006) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None parent_id=None s3prefix=None page_size=None page_offset=None num_rows=None result=None n_completed=None\n\n\n\nresults_variant_const = future_variant_const.wait(verbose=True)\nprint(len(results_variant_const))\n\n118it [05:36,  2.85s/it, status=SUCCESS]\n\n\n1618\n\n\n\nscores_variant_const = np.array([r.score for r in results_variant_const])\nscore_variant_const = scores_variant_const.mean(axis=1)\nscores_variant_const.shape, score_variant_const.shape\n\n((1618, 3), (1618,))\n\n\n\n_, ax = plt.subplots(figsize=(6, 4))\n\nx = score_variant_const\ny = table_variant['norm r.e.'].values\nax.scatter(x, y)\nax.set_title('Variant')\nprint('Variant', spearmanr(x, y))\n\nVariant SpearmanrResult(correlation=0.5441387133550285, pvalue=2.2734091856501145e-125)\n\n\n\n\n\n\n_ = plt.hist(score_variant_const, bins=30)"
  },
  {
    "objectID": "04_p2p_chorismate_case_study.html#use-this-prompt-to-generate-some-new-sequences",
    "href": "04_p2p_chorismate_case_study.html#use-this-prompt-to-generate-some-new-sequences",
    "title": "Connect to the OpenProtein.AI API",
    "section": "Use this prompt to generate some new sequences",
    "text": "Use this prompt to generate some new sequences\n\nfuture_gen = session.prots2prot.generate(prompt_const, num_samples=1000, topp=0.9)\nprint(future_gen.job)\n\nstatus=&lt;JobStatus.PENDING: 'PENDING'&gt; job_id='51a2d578-fff2-4d68-b9a8-30557285dd60' job_type='/workflow/prots2prot/generate' created_date=datetime.datetime(2023, 5, 2, 13, 26, 16, 71719) start_date=None end_date=None prerequisite_job_id=None progress_message=None progress_count=None\n\n\n\nresults_gen = future_gen.wait(verbose=True)\nprint(len(results_gen))\n\n873it [41:54,  2.88s/it, status=SUCCESS]\n\n\n1000\n\n\n\nsample_names = np.array([s.name for s in results_gen])\nsample_sequences = np.array([s.sequence for s in results_gen])\nsample_scores = np.array([s.score for s in results_gen]).mean(axis=1)\norder = np.argsort(-sample_scores)\nfor i in order[:10]:\n    print(sample_names[i], sample_scores[i], sample_sequences[i].decode(), sep='\\t')\n\ngenerated-sequence-267  -13.368366877237955 SSEKKLEEIRKRISEIDEQLITLIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCEECIECSVALKIIKILMEYNKEVQAEFFRKV\ngenerated-sequence-555  -13.830108960469564 QPNERLNDLRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKGVQNLSEKFMKELLYSIHEESVKRQEKQLRES\ngenerated-sequence-586  -13.896090507507324 QPNERLNDLRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKGVQNLSEKFMKELLYSIHEESVKRQEKQLKES\ngenerated-sequence-260  -17.756848017374676 LNDLRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKGVQNLSEKFMKELLYSIHEESVKRQERQLRES\ngenerated-sequence-379  -17.915011088053387 SEKRLEEIRKRISEIDEQLITLIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCEECIECSVALKIIKILMEYNKEVQAEFFRKL\ngenerated-sequence-222  -18.62750752766927  NKNLDLGELRSQLDEIDGQLVRLFEQRMKICADVAEYKIETGKAVYDGERERQKLEAVGAMAHGFNSQAVRELFSQLMTVSRKRQYQLLARH\ngenerated-sequence-513  -27.403642654418945 SSDAKLEEIRKRISEIDEQLIALIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCEECIECSVALKIIKILMEYNKEVQAEFFRKV\ngenerated-sequence-177  -29.403276761372883 TENPLLALRERISALDLKLLSLLAERRELAVEVGKTKLHSHRPIRDKERERDLLDALIAAAKYDLDGFYVTRLFQLIIEDSVLTQQSLLQNQ\ngenerated-sequence-164  -30.386859893798828 DLDRIRGQLDEIDGQLVRLFEQRMKLCADVAEYKIETGKAVYDGERERQKLEAVGAMAHGFNSQAVRELFSQLMTVSRKRQYQLLARH\ngenerated-sequence-877  -31.9000727335612   SDNPLLVLRERISALDLKLLTLLAERRELAVEVGKTKLHSHRPIRDKERERDLLDALIAAAKHDLDGFYVTRLFQLIIEDSVLTQQSLLQNQ\n\n\n\n#mi = min(np.min(score_variant_const), np.min(sample_scores))\nmi = np.min(score_variant_const)\nma = max(np.max(score_variant_const), np.max(sample_scores))\nbins = np.linspace(mi, ma, 31)\n\n_ = plt.hist(score_variant_const, bins=bins, alpha=0.5)\n_ = plt.hist(sample_scores, bins=bins, alpha=0.5)\n\n\n\n\n\nCompare these with the seed sequence used to build the prompt\n\nfrom Bio import pairwise2\nimport Bio.Align.substitution_matrices\nblosum62 = Bio.Align.substitution_matrices.load('blosum62')\n\n\nfor i in order[:10]:\n    x = sample_sequences[i].decode()\n    print(f'&gt;{sample_names[i]} {sample_scores[i]}')\n    for a in pairwise2.align.globalds(seed, x, blosum62, -11, -1):\n        print(pairwise2.format_alignment(*a))\n        break\n\n&gt;generated-sequence-267 -13.368366877237955\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n.||..|...|..||..||.|..|.|||...|.|....|......|.|..||.|..|....|.. ................|.....|.......\nSSEKKLEEIRKRISEIDEQLITLIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCE-ECIECSVALKIIKILMEYNKEVQAEFFRKV\n  Score=89\n\n&gt;generated-sequence-555 -13.830108960469564\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n.....|..||.....||..||..|.||.......|..|...|..|...||..|..|.....| ...|.......|...|.|.||..|...|...\nQPNERLNDLRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKG-VQNLSEKFMKELLYSIHEESVKRQEKQLRES\n  Score=84\n\n&gt;generated-sequence-586 -13.896090507507324\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n.....|..||.....||..||..|.||.......|..|...|..|...||..|..|.....| ...|.......|...|.|.||..|...|...\nQPNERLNDLRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKG-VQNLSEKFMKELLYSIHEESVKRQEKQLKES\n  Score=84\n\n&gt;generated-sequence-260 -17.756848017374676\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n...     ||.....||..||..|.||.......|..|...|..|...||..|..|.....| ...|.......|...|.|.||..|...|...\nLND-----LRRAVDHLDDQLLDILQERFAVIDQIGAHKREHHLSVFQSDRWKDVMESRTQKG-VQNLSEKFMKELLYSIHEESVKRQERQLRES\n  Score=76\n\n&gt;generated-sequence-379 -17.915011088053387\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n ||..|...|..||..||.|..|.|||...|.|....|......|.|..||.|..|....|.. ................|.....|.......\n-SEKRLEEIRKRISEIDEQLITLIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCE-ECIECSVALKIIKILMEYNKEVQAEFFRKL\n  Score=76\n\n&gt;generated-sequence-222 -18.62750752766927\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n.....|..||......|..|..|...|......|...|......|.|..|||..||.....  ||.........||......|...|..||..|\nNKNLDLGELRSQLDEIDGQLVRLFEQRMKICADVAEYKIETGKAVYDGERERQKLEAVGAM--AHGFNSQAVRELFSQLMTVSRKRQYQLLARH\n  Score=88\n\n&gt;generated-sequence-513 -27.403642654418945\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n.|...|...|..||..||.|.||.|||...|.|....|......|.|..||.|..|....|.. ................|.....|.......\nSSDAKLEEIRKRISEIDEQLIALIAERTGFAPEIASLKNSLGASVTDSKREQDICEQTRILCE-ECIECSVALKIIKILMEYNKEVQAEFFRKV\n  Score=88\n\n&gt;generated-sequence-177 -29.403276761372883\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n| |||||||||.|||||.|||.||||||||||||||.||.||||.||..||||||..||...| ..||..|.||||||||||||||||.|||..\nT-ENPLLALRERISALDLKLLSLLAERRELAVEVGKTKLHSHRPIRDKERERDLLDALIAAAK-YDLDGFYVTRLFQLIIEDSVLTQQSLLQNQ\n  Score=320\n\n&gt;generated-sequence-164 -30.386859893798828\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n....    .|......|..|..|...|..|...|...|......|.|..|||..||.....  ||.........||......|...|..||..|\nDLDR----IRGQLDEIDGQLVRLFEQRMKLCADVAEYKIETGKAVYDGERERQKLEAVGAM--AHGFNSQAVRELFSQLMTVSRKRQYQLLARH\n  Score=76\n\n&gt;generated-sequence-877 -31.9000727335612\nTSENPLLALREKISALDEKLLALLAERRELAVEVGKAKLLSHRPVRDIDRERDLLERLITLGKAHHLDAHYITRLFQLIIEDSVLTQQALLQQH\n |.||||.|||.|||||.|||.||||||||||||||.||.||||.||..||||||..||...| |.||..|.||||||||||||||||.|||..\n-SDNPLLVLRERISALDLKLLTLLAERRELAVEVGKTKLHSHRPIRDKERERDLLDALIAAAK-HDLDGFYVTRLFQLIIEDSVLTQQSLLQNQ\n  Score=317"
  },
  {
    "objectID": "prots2prot-tutorial.html",
    "href": "prots2prot-tutorial.html",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "Prots2prot is a generative protein language model that allows you to design protein sequences de novo, without functional measurements of your protein of interest. This means that you can use the model to generate single substitution, combinatorial variant libraries, or a bespoke high-diversity library, prior to making any measurements.\nProts2prot controls sequence generation via a prompt, which is defined as a set of sequences that encodes information about the local fitness landscape and co-evolutionary patterns of your given protein of interest. One way to build this prompt is by using a multiple sequence alignment (MSA) of your protein of interest using sequences across evolutionary lineages. Because these sequences share an evolutionary relationship, they contain information about the local fitness landscape of the protein. Prots2prot is able to infer the evolutionary process driving the generation of these sequences, and hence not only sample new sequences, but also score the likelihood of seeing a given sequence under this process.\nChorismate mutase is a important enzyme involved in the biosynthesis of aromatic amino acids. Specifically, it catalyzes the conversion of chorismate to prephenate. In this tutorial, we will use Prots2prot to generate a prospective de novo variant library for chorismate mutase.\n\n\nTo generate single-substitution libraries, we can use the Single site analysis prediction tool. This tool generates and scores all single-substitution variants of the given query sequence.\n\n\n\nFirst, define the query sequence for which we wish to generate all single substutions.\nNext, define the prompt. Recall that this is a set of sequences that implicitly describe the local fitness landscape of your protein of interest. The easiest way to do this is to paste the same query sequence and simply ask the tool to automatically generate the MSA from it. Here, our query sequence is the sequence encoding chorismate mutase in E. coli.\n\n\n\nInput query sequence\n\n\nAlternatively, if you already have an MSA or some other set of sequences that you wish to use as the prompt, you can also drop or select your own file.\n\n\n\nInput custom prompt\n\n\nAnd that’s all we need for the analysis! Click Run at the bottom of the page to generate and score all single site variant libraries. There are several other advanced options that we may want to play with after our initial run. However, the default options have been tuned to generate a reasonable starter library.\nWhen the run is complete, navigate to the Results tab to inspect the output of the run. At the top of the page is a summary detailing the score for the query sequence, as well as the number of sites and number of variants expected to improve over the input. The full results are presented as a heatmap, which you can mouse over for more detail. For convenience, the tables at the bottom of the page list the top 5 variants and sites.\n:bulb: The score assigned by Prots2prot is the log likelihood of the sequence under the model. This means that the larger (less negative) the score, the higher the probability of observing the sequence given the model.\nAs we can see, position 40 seems like a promising candidate for mutagenesis, with many mutations such as L&gt;D, L&gt;E and L&gt;A all improving over the query sequence.\n\n\n\nResults\n\n\nThe full results are available for export either as a csv or as a png. To do so, you can use the export button located at the top right hand corner of the page. Alternatively, you can also start a new single-site run against the same prompt either by selecting a particular variant sequence in the heatmap or in the table. Then, start a new single site analysis using Run new....\n\n\n\nExport\n\n\nCongratulations! :tada: You have now created your first de novo variant library using Prots2prot!\n\n\n\nTODO\n\n\n\nWhy should we care about generating high-diversity libraries? The typical strategy in protein engineering is to search the local sequence space near a known sequence by generating single and combinatorial variant libraries. However, this may not be the best strategy for several reasons:\n\nYou may not have a good starting sequence. In this case, you will want to cast your net as wide as possible by sampling a variety of stable and functional proteins. However, you still don’t want to be generating biologically impossible proteins.\nYou started with an ok sequence, but are stuck in a local optima. This means that there may be distant sequences that have even higher activity. However, these either cannot be found via a simple greedy optimization strategy, or may take an unreasonable number of steps to reach it.\n\n\n\n\nThis greedy algorithm is going in the direction of the best local improvementbut is actually moving further away from the global peak.\n\n\n\nYou want to hedge your bets. Unfortunately, similar sequences are likely to share other possibly unwanted, but correlated properties. For example, a set of similar sequences may all have high activity but may also all be unstable or poorly expressed. Just as with investing, it is good to diversity your portfolio.\n\nTo generate high-diversity libraries, we can use the Generate sequences tool.\n\n\n\nAs in the single-site analysis tool, we have to specify the prompt. We will again use the sequence for chorismate mutase in E. coli. to seed the MSA. Since chorismate mutase is a relatively short protein, we will set the maximum generated protein length to 200. We also set the number of sequences to generate to 100. Hitting run then dispatches the generate job.\n\n\n\nGenerate sequences\n\n\nThe results of the tool are returned in the Results tab as a table. Recall that the larger (less negative) the score, the higher the likelihood of the sequence under the model. We can use the table widget to filter our sequences to have some minimum score, and then export them for further analysis.\n\n\n\nFilter sequences\n\n\nHowever, looking at the table, we can already observe that only 1 sequence has a score higher than the original query sequence that we input in the original analysis. To generate more highly-scoring sequences, we might want to lower Top-p, which reduces the randomness of the sampling by only sampling from the top most likely amino acids up to the specified cumulative frequency. We can also lower the temperature, which emphasizes higher probability amino acids during sampling by raising the probability to the power of the temperature.\nLet’s try setting Top-p to 0.9! Here we can see that there are a lot more high-scoring sequences.\n\n\n\nFilter sequences\n\n\n:bulb: Hover the tooltips to learn about how the different parameters affect the results! Although we have set reasonable defaults for many of these parameters, we recommend that you also try playing around with them to customize your libraries.\n\n\n\nTo evaluate Prot2prot, we can take a look at how well Prot2prot’s scores predict actual activity measurements. If Prot2prot’s scores are predictive, this gives us confidence that the model has learned the underlying generative process and will be able to generate a good library.\n:bulb: How is it that Prots2prot scores can be predictive of function despite having never seen functional measurements? An excellent question! Well, it turns out that evolution has already done a lot of the work for us, and that there is a lot to learn from naturally occurring sequences. In fact, our experiments show that even though Prots2prot does not use any measurement information, Prots2prot scores correlate with functional measurements across diverse tasks in a wide variety of datasets. You can read more about these experiments in our upcoming preprint.\nLet’s evaluate Prot2prot’s scores against actual activity measurements for a high diversity variant library of chorismate mutase!\nTo evaluate query sequences against a given MSA, we can use the Create query tool.\n\n\n\n\n\n\nWe can also use Prot2prot to prioritize variants in an existing library."
  },
  {
    "objectID": "prots2prot-tutorial.html#generating-single-substitution-libraries",
    "href": "prots2prot-tutorial.html#generating-single-substitution-libraries",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "To generate single-substitution libraries, we can use the Single site analysis prediction tool. This tool generates and scores all single-substitution variants of the given query sequence.\n\n\n\nFirst, define the query sequence for which we wish to generate all single substutions.\nNext, define the prompt. Recall that this is a set of sequences that implicitly describe the local fitness landscape of your protein of interest. The easiest way to do this is to paste the same query sequence and simply ask the tool to automatically generate the MSA from it. Here, our query sequence is the sequence encoding chorismate mutase in E. coli.\n\n\n\nInput query sequence\n\n\nAlternatively, if you already have an MSA or some other set of sequences that you wish to use as the prompt, you can also drop or select your own file.\n\n\n\nInput custom prompt\n\n\nAnd that’s all we need for the analysis! Click Run at the bottom of the page to generate and score all single site variant libraries. There are several other advanced options that we may want to play with after our initial run. However, the default options have been tuned to generate a reasonable starter library.\nWhen the run is complete, navigate to the Results tab to inspect the output of the run. At the top of the page is a summary detailing the score for the query sequence, as well as the number of sites and number of variants expected to improve over the input. The full results are presented as a heatmap, which you can mouse over for more detail. For convenience, the tables at the bottom of the page list the top 5 variants and sites.\n:bulb: The score assigned by Prots2prot is the log likelihood of the sequence under the model. This means that the larger (less negative) the score, the higher the probability of observing the sequence given the model.\nAs we can see, position 40 seems like a promising candidate for mutagenesis, with many mutations such as L&gt;D, L&gt;E and L&gt;A all improving over the query sequence.\n\n\n\nResults\n\n\nThe full results are available for export either as a csv or as a png. To do so, you can use the export button located at the top right hand corner of the page. Alternatively, you can also start a new single-site run against the same prompt either by selecting a particular variant sequence in the heatmap or in the table. Then, start a new single site analysis using Run new....\n\n\n\nExport\n\n\nCongratulations! :tada: You have now created your first de novo variant library using Prots2prot!"
  },
  {
    "objectID": "prots2prot-tutorial.html#generating-combinatorial-variant-libraries",
    "href": "prots2prot-tutorial.html#generating-combinatorial-variant-libraries",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "prots2prot-tutorial.html#generating-high-diversity-libraries",
    "href": "prots2prot-tutorial.html#generating-high-diversity-libraries",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "Why should we care about generating high-diversity libraries? The typical strategy in protein engineering is to search the local sequence space near a known sequence by generating single and combinatorial variant libraries. However, this may not be the best strategy for several reasons:\n\nYou may not have a good starting sequence. In this case, you will want to cast your net as wide as possible by sampling a variety of stable and functional proteins. However, you still don’t want to be generating biologically impossible proteins.\nYou started with an ok sequence, but are stuck in a local optima. This means that there may be distant sequences that have even higher activity. However, these either cannot be found via a simple greedy optimization strategy, or may take an unreasonable number of steps to reach it.\n\n\n\n\nThis greedy algorithm is going in the direction of the best local improvementbut is actually moving further away from the global peak.\n\n\n\nYou want to hedge your bets. Unfortunately, similar sequences are likely to share other possibly unwanted, but correlated properties. For example, a set of similar sequences may all have high activity but may also all be unstable or poorly expressed. Just as with investing, it is good to diversity your portfolio.\n\nTo generate high-diversity libraries, we can use the Generate sequences tool.\n\n\n\nAs in the single-site analysis tool, we have to specify the prompt. We will again use the sequence for chorismate mutase in E. coli. to seed the MSA. Since chorismate mutase is a relatively short protein, we will set the maximum generated protein length to 200. We also set the number of sequences to generate to 100. Hitting run then dispatches the generate job.\n\n\n\nGenerate sequences\n\n\nThe results of the tool are returned in the Results tab as a table. Recall that the larger (less negative) the score, the higher the likelihood of the sequence under the model. We can use the table widget to filter our sequences to have some minimum score, and then export them for further analysis.\n\n\n\nFilter sequences\n\n\nHowever, looking at the table, we can already observe that only 1 sequence has a score higher than the original query sequence that we input in the original analysis. To generate more highly-scoring sequences, we might want to lower Top-p, which reduces the randomness of the sampling by only sampling from the top most likely amino acids up to the specified cumulative frequency. We can also lower the temperature, which emphasizes higher probability amino acids during sampling by raising the probability to the power of the temperature.\nLet’s try setting Top-p to 0.9! Here we can see that there are a lot more high-scoring sequences.\n\n\n\nFilter sequences\n\n\n:bulb: Hover the tooltips to learn about how the different parameters affect the results! Although we have set reasonable defaults for many of these parameters, we recommend that you also try playing around with them to customize your libraries."
  },
  {
    "objectID": "prots2prot-tutorial.html#how-good-are-my-libraries",
    "href": "prots2prot-tutorial.html#how-good-are-my-libraries",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "To evaluate Prot2prot, we can take a look at how well Prot2prot’s scores predict actual activity measurements. If Prot2prot’s scores are predictive, this gives us confidence that the model has learned the underlying generative process and will be able to generate a good library.\n:bulb: How is it that Prots2prot scores can be predictive of function despite having never seen functional measurements? An excellent question! Well, it turns out that evolution has already done a lot of the work for us, and that there is a lot to learn from naturally occurring sequences. In fact, our experiments show that even though Prots2prot does not use any measurement information, Prots2prot scores correlate with functional measurements across diverse tasks in a wide variety of datasets. You can read more about these experiments in our upcoming preprint.\nLet’s evaluate Prot2prot’s scores against actual activity measurements for a high diversity variant library of chorismate mutase!\nTo evaluate query sequences against a given MSA, we can use the Create query tool."
  },
  {
    "objectID": "prots2prot-tutorial.html#prioritizing-variants-in-an-existing-library",
    "href": "prots2prot-tutorial.html#prioritizing-variants-in-an-existing-library",
    "title": "Designing de novo variant libraries",
    "section": "",
    "text": "We can also use Prot2prot to prioritize variants in an existing library."
  },
  {
    "objectID": "jupyter-notebook-exemple.html",
    "href": "jupyter-notebook-exemple.html",
    "title": "Jupyter Notebook Example",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "jupyter-notebook-exemple.html#polar-axis",
    "href": "jupyter-notebook-exemple.html#polar-axis",
    "title": "Jupyter Notebook Example",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  }
]