<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Open protein – full</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      <img src="../../logo.svg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Basics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../getting-started-page.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">getting-started-page.html</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Prots2prot</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../prots2prot-tutorial-page.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Designing <em>de novo</em> variant libraries using Prots2prot</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<p>Guide # At a glance</p>
<p>This user guide provides a basic overview of the OpenProtein.AI web app. You can create your first project, upload a dataset, and then use the OpenProtein.AI tools to analyze that dataset, train sequence-to-function prediction models, predict properties for new sequences, and design optimized libraries. It also overviews the generative modeling capabilities of the prots2prot model.</p>
<p>## Introduction to OpenProtein</p>
<p>This section gives an overview of the platform and its features. It is a good place to start to learn how to use the platform and what it can offer. ## Demo datasets</p>
<p>[Links] to download the walkthrough dataset and several other demo datasets.</p>
<p>## ML-guided mutagenesis and sequence-to-function modeling walkthrough</p>
<p>A simple walkthrough of the OpenProtein.AI web app and the tools it provides for analyzing mutagenesis datasets, training sequence-to-function prediction models, using those models to predict properties for new sequences, and designing optimized libraries of sequence variants. This walkthrough uses a deep mutational scanning dataset of an aliphatic amide hydrolase from Pseudomonas aeruginosa generated by [Wrenbeck et al.](https://doi.org/10.1038/ncomms15695).</p>
<p>## Generative modeling and variant fitness prediction with prots2prot</p>
<p>Prots2prot is a guidable, retrieval-augmented generative model of protein sequences. It conditions on homologues or protein family representatives to predict variant effects and allow diverse sequence design de novo. Prots2prot can be used to score and rank arbitrary sequence variants, exhaustively map single substitution mutations, and design bespoke, potentially high diversity, and novel sequences. Prots2prot can be used to score and design substitutions, insertions, deletions, and high order combinations thereof.</p>
<p>________________</p>
<p># Introduction to Open Protein[b]</p>
<p>Open Protein is a platform that helps you . This article includes a high-level summary of core features, along with links to explore more documentation for each area.</p>
<p>## Project</p>
<p>This is the overall folder where your datasets, designs and libraries will be housed in. You can create more than 1 project. Learn more about [projects] (https://docs.openprotein.ai/project).</p>
<p>## Datasets</p>
<p>Once you have uploaded your datasets, you will be able to view them here. Our system automatically creates a UMAP, joint plot and histogram. You will be able to upload multiple datasets. Learn more about [uploading your datasets] (https://docs.openprotein.ai/uploads)[c].</p>
<p>![Caption](1_new_upload.png) ## Designs</p>
<p>The design module allows you to create the best base sequences based on specific properties. Once you have run the design tool, you can find your optimized sequences in this module. Learn more about [Design] (https://doc.openprotein.ai/design/).</p>
<p>## Libraries</p>
<p>The Libraries module allows you to store your design sequences for easy reference. Learn more about [Libraries] (https://doc.openprotein.ai/libraries/).</p>
<p>________________ # Account[d]</p>
<p>## Logging into your account</p>
<p>Login to the [web platform] (https://app.openprotein.ai) with your username and password.</p>
<p>![Caption](01_login.png)</p>
<p>## Resetting your password</p>
<p>To change your password, navigate to the account icon on the top right corner of the page, and click on ‘Change password’.</p>
<p>![Caption](02_change_password.png) ________________ Projects[e]</p>
<p># Dataset ## Preparing your dataset for upload</p>
<p>A dataset is expected to be uploaded as a CSV formatted table. It should have the following columns: * the full sequence of each variant and * additional columns with measurement values associated with each variant.</p>
<p>![Caption](03_csv_seq.png)</p>
<p>To upload your dataset to the protein engineering platform, format it as a CSV table with two columns: the full sequence of each variant and additional columns with measurement values. Missing measurements are acceptable.</p>
<p>If you use mutation codes, specify the full wildtype sequence in the "Sequence options" dropdown, and the platform will enumerate the full sequence of each variant.</p>
<p>![Caption](04_csv_mutant.png)</p>
<p>## Creating a project</p>
<p>Upon first login, you will be prompted to create a project. You can name the project and include a description for your reference. ![Caption](05_new_project.png)</p>
<p>## Uploading a dataset</p>
<p>You can upload your dataset by clicking on the ‘Upload dataset’ button in the navigation panel or the project landing page. This will open a file explorer where you can select your dataset file.</p>
<p>![Caption](06_upload_main.png)</p>
<p>You have the option to edit the name of your dataset to your preference. By default, the name of the uploaded file is used. Additionally, you can add an optional description to provide more information about your dataset. To change the selected file, you can click on the “Change…” button to return to the file explorer and select a different file.</p>
<p>![Caption](07_new_upload.png)</p>
<p>The application will automatically detect the column where your sequences are based on the column name. If the column cannot be found, you can manually select it from the "Sequence options" dropdown.</p>
<p>![Caption](08_seq_options.png)</p>
<p>If your table encodes variants using mutant codes, please ensure that you include the wildtype sequence of your protein.</p>
<p>![Caption](09_wild_type.png)</p>
<p>Once you're ready, click "Upload" to initiate the upload process.</p>
<p># Visualizations</p>
<p>OpenProtein offers a suite of visualizations which also allows customizations: * UMAP * Joint plot</p>
<p>## UMAP</p>
<p>The UMAP creates a 2D visualization of the manifold of your sequence variants, using a low-dimensional embedding technique to represent each variant sequence in two dimensions based on their similarities in the high-dimensional feature space. Each point in the visualization represents a single sequence variant.</p>
<p>![Caption](10_umap.png)</p>
<p>The points are colored by their corresponding property values in your dataset. The “UMAP options” panel allows you to change the color scheme, reverse the color scheme, and toggle between multiple properties.</p>
<p>## Joint plot You can explore your dataset by selecting properties to view a joint plot that depicts the pairwise relationships between them. The joint plot provides a visual representation of the distribution of individuals of each variable and helps in understanding the relationship between two variables.</p>
<p>![Caption](11_jp.png)</p>
<p># Job status</p>
<p>View the status of your Prediction and Design jobs in the jobs panel on the right side of the page.</p>
<p>![Caption](12_job_status.png)</p>
<p>________________ Predictions # Making predictions ## Training model(s)</p>
<p>On the ‘Dataset’ tab, click on ‘Start training’. You can name your model and select which properties you want to be able to predict. We’ll call our model “Model” and fit it for all three properties here. ![Caption](13_train.png)</p>
<p>After model training is complete, the app will automatically evaluate the predictive performance using cross-validation. To view the training curves and cross-validation results, navigate to the “Diagnostics” tab.</p>
<p>Cross-validation is a reliable method to estimate the expected performance of the models in predicting properties for new variants. The app splits your variants into 5-folds, trains the model on four folds, and predicts the held-out fold. The cross-validation plots display the predicted properties versus the actual measured properties for each held-out variant.</p>
<p>What does it mean: A high correlation between the predicted and ground truth values suggests that the models can accurately predict the substrate activity for new sequence variants.</p>
<p>________________ # Running a prediction</p>
<p>This page allows you to enter an arbitrary variant sequence and make property predictions for that sequence and all single variants of it using your trained models. Click “Predict sequence…” or right click a sequence in the variants table and select “Predict this sequence” to go to the prediction page.</p>
<p>![Caption](14_predict_table.png)</p>
<p>Click “Run a new prediction…”, select your models, and click run. This may take a few minutes if the system is busy. Feel free to navigate away.</p>
<p>________________</p>
<p># Prediction results</p>
<p>Once the prediction job is finished, you will be presented with a table that contains: * predicted property values and * standard deviations for your query sequence.</p>
<p>Standard deviations indicate the degree of uncertainty in the predicted property value for your query. Additionally, a heatmap will be displayed that shows the favorability of each substitution mutant of your query sequence based on their predicted properties.</p>
<p>To customize the variant score based on the predicted property values, you can open the "Show heatmap options" drawer. Here, you can define the variant score by setting whether a property should be greater than, less than, or as close as possible to a target value, which you can set for each property.</p>
<p>![Caption](15_predict_seq.png)</p>
<p>You can also toggle properties on and off using the check marks, adjust how the individual properties are weighted in the score, and modify the color scaling of the heatmap by changing the minimum, mid, and maximum values.</p>
<p>![Caption](16_heatmap_op.png)</p>
<p>## Heatmaps The heatmap provides a means to explore alternative design objectives by adjusting the scoring criteria in the heatmap options. The "Export" button allows you to download the single-site predictions as a CSV table.</p>
<p>![Caption](17_heatmap.png)</p>
<p>________________</p>
<p>Design # Running the Design tool</p>
<p>Under ‘Dataset on the left panel’, select your desired dataset and click on “Create a design”. This will take you to a new page where you can define your design objectives and then the platform will search for sequence variants most likely to achieve those objectives.</p>
<p>To explore tradeoffs between the number of mutations in each variant and predicted properties, choose the "Use number of mutations criteria" option and set criteria for multiple properties.</p>
<p>![Caption](18_parameter.png)</p>
<p>The design algorithm is set to run for 10 steps by default. However, to generate more candidate sequences and allow the algorithm more time to find potentially better variants, this number can be increased.</p>
<p>![Caption](19_iteration.png)</p>
<p>After adjusting the settings, click “Generate design” to initiate the algorithm. The design will be saved and can be accessed from the navigation panel. Please note that the algorithm may take some time to complete, but you will be able to view the results as they are generated.</p>
<p>________________</p>
<p># Design Criteria</p>
<p>Property predictors in OpenProtein.AI are Bayesian. They output a distribution over possible values of the property for a variant. The mean is what you would get from a typical regression model, but our models also output a standard deviation which indicates how certain we are in the value of that property. Based on this distribution, we can calculate the probability that a sequence variant meets some design goal defined by the property value being greater than or less than some target value. This is how our design criteria are defined. The score given by the predictive models is the log probability that the sequence meets the defined design criteria.</p>
<p>This means that it is important to set reasonable target values for your design criteria, because it has a direct impact on the behaviour of the search algorithm. If the target value is set too ambitiously, then the algorithm will favor exploration by proposing variants with high uncertainty. Why? Because no variant will have expected property value at or beyond the target value, so variants with high uncertainties will be more likely to achieve the design criteria than sequences with low uncertainties. In other words, the model is certain that those variants will not achieve the design objective and it will explore high uncertainty variants instead. This will generally cause the algorithm to explore variants more distant from your mutagenesis dataset.</p>
<p>________________</p>
<p># Examining design results</p>
<p>This article details the suite of visualizations methods available on the platform ## UMAP Once the algorithm finishes, you’ll see the variant sequences generated by the design process overlaid on the UMAP. To distinguish between variants, you can adjust the color settings and change the property the new points are colored by in the color options panel. The designed sequences are colored by predicted properties.</p>
<p>![Caption](20_results.png)</p>
<p>## Histogram</p>
<p>You can view histograms comparing the expected property distributions for the designs against your original library and joint plots for all of the properties in the “Histogram” and “Joint plot” tabs.</p>
<p>![Caption](21_hist.png)</p>
<p>## Joint plots</p>
<p>You can view joint plots for all of the properties under the “Joint plot” tab.</p>
<p>![Caption](22_jp_results.png)</p>
<p>Note that these show all sequences in the design table, not just the best.</p>
<p>Below the plots, you can see the table of the generated sequences. The design algorithm may not generate all unique sequences at every step, so you can filter the table to only show unique sequences using the option in “Advanced filters.” You can sort the sequences by predicted property and the score assigned to each according to your design criteria. For score, larger (closer to zero) is better.</p>
<p>![Caption](23_design_table.png)</p>
<p>The filter icon next to each column name also allows you to set simple filters that can be applied to the designs.</p>
<p>![Caption](24_filter.png)</p>
<p># Exporting results</p>
<p>The design table can be downloaded as a CSV to work with in other software using the “Export…” button. You can choose to download the whole table or only your currently filtered rows.</p>
<p>![Caption](25_export.png)</p>
<p>Libraries # Saving sequence variants as a library</p>
<p>Libraries serve as a repository of all your designed sequence variants. This enables you to reference previously created variants easily.</p>
<p>You can also save your library within the app. Click the “Save as library…” button and enter a name for your library.</p>
<p>![Caption](26_save_library.png)</p>
<p>This will take you to a new page with the sequence variants you selected. You can navigate back to these sequences from the library section of the navigation menu.</p>
<p>![Caption](27_variant.png)</p>
<p>That’s it! Now you can download your designed sequence variants to perform any additional analysis and synthesize your library!</p>
<p>Walkthrough</p>
<p># Demo datasets</p>
<p>## Aliphatic amidase (AMIE_PSEAE)</p>
<p>This dataset is a single mutation site saturating dataset from [Wrenbeck et al.](https://doi.org/10.1038/ncomms15695) containing activity measurements for enzyme variants against three different substrates. The parent sequence is AMIE_PSEAE (UniProt identifier P11436).</p>
<p>6,819 entries with 3 properties. [Download](https://drive.google.com/uc?export=download&amp;id=1VteqroPbm2iJl2osfm5-uEZW-9m4WUyM)</p>
<p>## Antibody heavy chain (14H)</p>
<p>This dataset contains binding affinity measurements to the target for a random mutagenesis library containing single, double, and triple mutants of an antibody heavy chain variable region from [Li et al.] (https://doi.org/10.1101/2022.10.07.502662). Mutations were limited to CDRs 1, 2, and 3. Measurements are log base 10 of the binding Kd in nM.</p>
<p>7,476 entries with 1 property. [Download](https://drive.google.com/uc?export=download&amp;id=1L4AeuW50EKFKczxLf_YCUM4lC370eNqe)</p>
<p>## Antibody light chain (14L)</p>
<p>This dataset contains binding affinity measurements to the target for a random mutagenesis library containing single, double, and triple mutants of an antibody light chain variable region from [Li et al.](https://doi.org/10.1101/2022.10.07.502662). Mutations were limited to CDRs 1, 2, and 3. Measurements are log base 10 of the binding Kd in nM.</p>
<p>14,339 entries with 1 property. [Download] (https://drive.google.com/uc?export=download&amp;id=17fbByoS2pF6_e8xAVdMNcIF1gifaEzd2) ## Aminoglycoside 3'-phosphotransferase (KKA2_KLEPN)</p>
<p>This is a single mutation site saturating dataset from [Melnikov et al.] (https://doi.org/10.1093/nar/gku511) containing measurements of E. coli growth in the presence of six different antibiotics. This protein is a kinase that confers antibiotic resistance, hence, growth measures the activity of the kinase on these antibiotic substrates. The parent sequence is KKA2_KLEPN (UniProt identifier P00552)</p>
<p>5,279 entries with 6 properties. [Download](https://drive.google.com/uc?export=download&amp;id=1UE0Lx9EP3tcgpFeduSrFNysBo9rX_rgT) # ML-guided mutagenesis and sequence-to-function modeling walkthrough</p>
<p>This section is intended as a simple walkthrough of the OpenProtein.AI web app and the tools it provides for analyzing mutagenesis datasets, training sequence-to-function prediction models, using those models to predict properties for new sequences, and designing optimized libraries of sequence variants. This walkthrough uses a deep mutational scanning dataset of an aliphatic amide hydrolase from Pseudomonas aeruginosa generated by [Wrenbeck et al.] (https://doi.org/10.1038/ncomms15695).</p>
<p>You may download the dataset [here](https://doc.openprotein.ai/demo).</p>
<p>## Upload a dataset</p>
<p>After creating your [project] (insert link - creating a project), you will be prompted to upload a dataset. You can do so by clicking “Upload dataset” in the navigation panel or the project landing page will open a file explorer from which you can select your dataset file.</p>
<p>![Caption](06_upload_main.png)</p>
<p>We’ll use AMIE_PSEAE_Whitehead, a deep mutational scanning dataset from [Wrenbeck et al] (https://doi.org/10.1038/ncomms15695) which is included as a demo dataset with this walkthrough. This dataset has activity measurements for [single substitution mutants of aliphatic amidase from Pseudomonas aeruginosa](https://www.uniprot.org/uniprotkb/P11436/entry) on three substrates (acetamide, isobutyramide, and propionamide). This enzyme catalyzes the hydrolysis of short-chain aliphatic amides into carboxylates and ammonia.</p>
<p>![Caption](07_new_upload.png)</p>
<p>By default, it will be the name of your uploaded file but you have the option of renaming your dataset . You can also add an optional description. If you selected the wrong file by accident, the “Change…” button will take you back to the file explorer to select a different file.</p>
<p>:::{.callout-note} A note on mutagenesis dataset formats</p>
<p>A Mutagenesis dataset is expected to be uploaded as a CSV formatted table. It should have one column containing the full sequence of each variant and additional columns with measurement values associated with each variant.</p>
<p>It’s ok if some of the variants are missing measurements.</p>
<p>Your sequence variants can also be specified using typical mutation codes (e.g., M1A or R25L, encoding an M-&gt;A substitution at position 1 or R-&gt;L substitution at position 25, respectively). If your table has mutation codes, you will also need to specify the full wildtype sequence in the “Sequence options” dropdown. The app will use this to enumerate the full sequence of each variant. :::</p>
<p>The app will try to auto-detect your sequence column based on the column name. If it can’t find the column, you can manually select it in the “Sequence options” dropdown.</p>
<p>![Caption](08_seq_options.png)</p>
<p>If your table has variants encoded using mutant codes, you need to include the wildtype sequence of your protein.</p>
<p>![Caption](09_wild_type.png)</p>
<p>When you click “Upload,” your dataset will appear in the Datasets section of the navigation panel and you will be redirected to a new page for your dataset.</p>
<p>![Caption](28_walk_main.png)</p>
<p>## Job status</p>
<p>View the status of your jobs in the jobs panel on the right side of the page.</p>
<p>![Caption](12_job_status.png)</p>
<p>## Visualizations</p>
<p>The UMAP creates a 2D visualization of the manifold of your sequence variants that best reflects the similarities between your sequences in the high-dimensional feature space. You may find out more about UMAPs [here](/projects).</p>
<p>![Caption](10_umap.png)</p>
<p>In this case, we see a star-like pattern, which reflects the fact that this dataset is single variants of the central wildtype sequence. Mutagenesis datasets with higher diversity or that are generated in less systematic ways (e.g., via selection), will tend to display different cluster structures in the UMAP plot.</p>
<p>The points are colored by their corresponding property values in your dataset. The “UMAP options” panel allows you to change the color scheme, reverse the color scheme, and toggle between multiple properties.</p>
<p>In the meantime, you can select properties to view a joint plot showing pairwise relationships between them in your dataset.</p>
<p>![Caption](11_jp.png)</p>
<p>The “Dataset” tab will show your mutagenesis dataset table, allows some simple filtering and sorting of the variants, and allows you to download your dataset as a CSV with the “Export…” button.</p>
<p>![Caption](29_dataset_table.png)</p>
<p>Training model on mutagenesis dataset Next, we will train sequence-to-function prediction models on your mutagenesis dataset to predict your property(ies). These models can be used later on to make predictions for new sequence variants and to design libraries of optimized sequences. Click “Train a model…” to open the model training options panel. You can name your model and select which properties you want to be able to predict. We’ll call our model “Model” and fit it for all three properties here.</p>
<p>![Caption](13_train.png)</p>
<p>Click “Start training” and you’ll see two new jobs added to your jobs panel.</p>
<p>![Caption](30_job_status.png)</p>
<p>Once your models finish training, they will appear in the models panel. Your models will be named according to the name you entered in the training options and the property each model predicts.</p>
<p>![Caption](31_model_status.png)</p>
<p>## Model diagnostics and cross validation</p>
<p>The app will also automatically evaluate the predictive performance of these models using cross validation once the models finish training. Navigate to the “Diagnostics” tab to see training curves and cross validation of the models.</p>
<p>For cross validation, we split your variants into 5-folds, and, for each fold, fit the model on the other 4, then make predictions on the heldout fold. The cross validation plots show the predicted properties versus your actual measured properties for each variant in your dataset when it was heldout. Here, we can see that the model predictions correlate strongly with the ground truth measurements, indicating that these models are able to accurately predict substrate activity for unseen sequence variants.</p>
<p>![Caption](32_cross_valid.png)</p>
<p>________________ ## Make predictions and analyze single variant properties</p>
<p>Once you have trained models, these models can be used to predict those properties for sequence variants of interest. This allows you to explore specific variants and see their predicted properties and also to examine the predicted properties of all single substitution variants of a parent sequence.</p>
<p>### Running a prediction</p>
<p>Click “Predict sequence…” or right click a sequence in the variants table and select “Predict this sequence” to go to the prediction page. Here, we sort by isobutyramide activity and select the variant with highest activity to analyze single site variants of.</p>
<p>![Caption](14_predict_table.png)</p>
<p>This page allows you to enter an arbitrary variant sequence and make property predictions for that sequence and all single variants of it using your trained models.</p>
<p>![Caption](33_predict_seq.png)</p>
<p>Click “Run a new prediction…”, select your models, and click run. This may take a few minutes if the system is busy. Feel free to navigate away. Next time you come back to this sequence, the prediction results will be stored so they can be retrieved quickly later.</p>
<p>![Caption](34_predict_seq_run.png)</p>
<p>### Examining predict results</p>
<p>When the predict job completes, you’ll see a table with predicted property values and standard deviations for your query sequence. You’ll also see a heatmap showing the favorability of each single substitution mutant of your query sequence based on their predicted properties.</p>
<p>:::{.callout-note} Important: open the “Show heatmap options” drawer. Here, you can edit the definition of the variant score based on the predicted property values. You can set whether a property should be greater than, less than, or as close as possible to a target value which you can set for each property. You can also toggle properties on and off using the check marks and change how the individual properties are weighted in the score. See the note on design criteria below in the “Design optimized variants” section for more information. The right side of the panel shows the relationship between variant scores and the color map. You can change the min, mid, and max values to adjust the color scaling of the heatmap. :::</p>
<p>For this dataset, let’s look for variants likely to have activity &gt;1 on all three substrates. We also set the min score for the colormap to -20 to get better color resolution of the possible variants.</p>
<p>![Caption](35_color_map.png)</p>
<p>Since we started with a high activity sequence, we can see that most variants are predicted to be less likely to achieve our design criteria. These are colored red by default.</p>
<p>![Caption](36_heatmap_main.png)</p>
<p>There’s only one variant that our models predict are more likely to achieve the design objective than, which is colored blue. Hovering that cell of the heatmap will show more information about it.</p>
<p>![Caption](37_heatmap_para.png)</p>
<p>You can look for variants that might be better for other design objectives by editing the scoring criteria in the heatmap options drawer. For example, if we look only at isobutyramide, we can find some other substitutions that might be beneficial.</p>
<p>![Caption](38_heatmap_var.png)</p>
<p>You can download the single site predictions as a CSV table with the “Export” button. ________________ ## Designing optimized variants</p>
<p>Predict is useful if you want to understand the predicted properties and single mutant potentials for some specific sequences. But what if you don’t know what the best base sequence is or want to design a library of higher order mutants that optimally trade off your properties and explore sequence space? That’s what the design module is for.</p>
<p>### Running the design tool</p>
<p>Return to the dataset page and select “Create a design…” This will take you to a new page where you can define your design objectives and then the platform will search for sequence variants most likely to achieve those objectives.</p>
<p>![Caption](18_parameter.png)</p>
<p>Here, we want to look for variants likely to have activity &gt;1 on all substrates. You can edit the name of this design run in the name text box. We’ve changed it to “AMIE all &gt;1.” You can also specify specific positions within the sequence to mutate. If you don’t, all positions will be considered. The single site potentials found on the predict page can be a useful way to identify a limited number of positions, but we’ll just consider all positions here. You can also set the design algorithm to find optimal variants at shells of similarity to your dataset by selecting the “Use number of mutations criteria” option. This can be helpful if you want to explore tradeoffs between the number of mutations in each variant and the predicted properties. When a criteria is set for multiple properties, the algorithm will search for variants that fall along the Pareto front of those criteria. More information on the design criteria can be found here.</p>
<p>By default, the design algorithm will run for 10 steps. If you want to generate more candidate sequences and give the algorithm more time to find, potentially, better variants, this can be increased. Let’s set it to 20.</p>
<p>![Caption](19_iteration.png)</p>
<p>Then click “Generate design” to start the algorithm. This will save the design so it’s accessible from the navigation panel. It can take some time for the algorithm to run. Once it starts, you’ll be able to see results as they are generated by the algorithm.</p>
<p>![Caption](39_generate_design.png)</p>
<p>## Examining design results</p>
<p>As results are being generated and once the algorithm finishes, you’ll see the variant sequences generated by the design process overlaid on the UMAP. You can adjust the color settings and change the property the new points are colored by in the color options panel. The designed sequences are colored by predicted property.</p>
<p>![Caption](40_design_result.png)</p>
<p>You can view histograms comparing the expected property distributions for the designs against your original library and joint plots for all of the properties in the “Histogram” and “Joint plot” tabs.</p>
<p>![Caption](41_design_hist.png)</p>
<p>![Caption](42_design_jp.png)</p>
<p>Note that these show all sequences in the design table, not just the best.</p>
<p>Below the plots, you can see the table of the generated sequences. The design algorithm may not generate all unique sequences at every step, so you can filter the table to only show unique sequences using the option in “Advanced filters.” You can sort the sequences by predicted property and the score assigned to each according to your design criteria. For score, larger (closer to zero) is better.</p>
<p>![Caption](43_advanced_filt.png)</p>
<p>The filter icon next to each column name also allows you to set simple filters that can be applied to the designs.</p>
<p>![Caption](44_filter.png)</p>
<p>You can now download designs and save as a library accordingly.</p>
<p>That’s it! Now you can download your designed sequence variants to perform any additional analysis and synthesize your library!</p>
<p># Prots2prot: Generative modeling and variant fitness prediction Prots2prot is a generative protein language model that allows controllable design of protein sequences and variant effect prediction. This model is controlled by providing it with a prompt, a set of sequences that represent homologues, family members, or some other grouping of related sequences that represent your protein of interest. We provide tools for creating these prompts from multiple sequence alignments (MSAs) and for using homology search to build MSAs from a seed sequence.</p>
<p>Given a prompt, you can * Score arbitrary sequences you provide to predict sequence fitness and rank variants. This works for substitutions and indels and allows high order variants. * Map the fitness of all single substitution variants. This is useful for designing single mutant libraries, but also for identifying mutable hotspots and designing combinatorial variant libraries. * Generate novel, bespoke, high order variants by sampling from the model. This is especially useful for synthetic diversification and exploring the full and potentially diverse sequence space of your protein.</p>
<p>Accessing prots2prot</p>
<p>Prots2prot tools can be found in the “Prots2prot…” dropdown menu in the header bar of the OpenProtein.AI web app.</p>
<p>From here, you can access specific prots2prot tools: History, Create query, Single site analysis, and Generate sequences.</p>
<p>Defining the prompt</p>
<p>The prompt defines the target sequence distribution. It provides the prots2prot model with information about sequence constraints, local fitness landscape, and co-evolutionary patterns, from which prots2prot will infer a generative model over protein sequences. The prompt definition tools allow you to specify and control what sequences are used to define this generative context.</p>
<p>The primary way to define a prompt is to provide a seed sequence, which could be your parent sequence, or some other sequence representing the space of proteins within which you would like to sample or explore. To use this option, check the “Use first sequence as seed to generate MSA” box. The seed sequence will then be used to build out a multiple sequence alignment of naturally occurring homologous sequences from which the prompt sequences will be randomly selected. You may also provide your own set of homologous sequences as an MSA, from which the prompt will be created. Note that if you provide your own MSA, the first sequence will be considered the seed sequence.</p>
<p>This sampling process is controlled by the sampling strategy, homology level, and maximum and minimum similarity parameters. These are set to reasonable values by default, which we have found to perform well across a wide range of protein families. These can be tuned, however, to control the diversity of sequences that will be modeled by prots2prot.</p>
<p>Sampling strategy - this parameter defines the sampling strategy used for selecting prompt sequences from the homologues found by homology search, or from the provided MSA. We recommend using the default “Neighbors” method. Homology level - this parameter controls the identity level at which two sequences are considered “neighbors” - that is, redundant - in the MSA. This is equivalent to the homology level used to calculate the number of effective sequences in protein families. Maximum similarity - the maximum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity greater than this to the seed will be included. Minimum similarity - the minimum similarity to the seed sequence allowed when selecting sequences for the prompt. No sequence with identity less than this to the seed will be included. This is useful for creating prompts that are highly focused on the local sequence space around the seed.</p>
<p>If your protein comes from a highly diverse family or you wish to explore a large and diverse set of variants, then adjusting the homology level to be lower will select higher diversity prompt sequences and thus generate higher diversity sequence distributions. On the other hand, if you wish to have more focused generation, then using a higher homology level and setting a minimum similarity threshold can help to ensure that the prompt focuses on the local sequence landscape around your seed.</p>
<p>Ensembling - instead of using a single prompt, multiple randomly sampled prompts can be used together by ensembling. We’ve found that this consistently improves performance when predicting variant effects by a small amount, but it will also make predictions and sampling take more time. To build an ensemble prompt, set the number of prompts to ensemble to a number &gt;1. Three to five are generally enough, but we allow up to 15 prompts to be ensemble. There are diminishing returns to adding more prompts to the ensemble.</p>
<p>History</p>
<p>The prots2prot history page allows you to view and access past jobs, sorted by created date, job type, and status. Clicking the job ID will take you to the results page for that job. It also provides quick access to the specific prots2prot tools in the bottom bar.</p>
<p>Scoring sequences with prots2prot Click “Create query” to go to the query tool. This tool allows you to score arbitrary sequences defined in a fasta or CSV file. It will calculate the log-likelihood of each sequence conditioned on the sequence context defined by the prompt.</p>
<p>This tool is useful if you want to score, prioritize, or rank specific sequence variants of interest. For example, you could score homologous sequences mined from a database, perform a synthetic alanine scan or deletion scan, or enumerate combinatorial mutations at specific sites.</p>
<p>Clicking “run” will start the job. This could take a few minutes depending on how busy the service is, how long your sequences are, and how many sequences you want to score.</p>
<p>The results are presented as a table, which can be sorted and downloaded. You can further explore the local fitness landscape of each sequence by using the quick links to the Single site analysis page. This will run single site analysis for the specified sequence with your prompt. You can also add new sequences to the job using the “Add sequences” button.</p>
<p>Single site analysis Click “Single site analysis” to go to the single site analysis tool. This tool will score all single substitution variants of a parent sequence, conditioned on the prompt, and present the results in a heatmap.</p>
<p>Results can be downloaded as a table using the “Export” button. The single site page will also show the highest scoring variants and sites in tables below the heatmap for quick reference. The parameters used to run the single site analysis can be found in the “Single site details” tab.</p>
<p>Clicking on a variant in the heatmap will open the “Run new” drawer and fill in that variant to provide a quick link to run single site analysis on that variant as the parent sequence using the same prompt. You can also enter an arbitrary sequence in “Run new” to run single site analysis for other sequences without respecifying the prompt.</p>
<p>For example,</p>
<p>Single site analysis is useful if you want to understand the local fitness landscape of a protein, identify promising single substitution variants, identify hotspots for mutagenesis, and design combinatorial variant libraries.</p>
<p>Generate novel sequences Click “Generate sequences” to go to the sequence generation tool. This tool allows you to sample novel protein sequences conditioned on the sequence context provided by your prompt sequences. This tool offers a way to explore and efficiently generate functional sequences from the fitness landscape around your prompt sequences. Generate is ideal for designing high diversity, bespoke protein sequence libraries and can sample non-trivial and variable length sequences.</p>
<p>The sampling behaviour can be controlled by tuning your prompt and through the sampling options provided. In particular, “temperature,” “top-p,” and “top-k” provide the ability to focus sampling around highly likely sequences by adjusting these parameters.</p>
<p>Generated sequences are presented in a table similar to the Query results above.</p>
<p>The table can be downloaded using the “Export” button and local fitness landscapes are quickly accessible via the single site analysis buttons for each sequence.</p>
<p>[a]landing page [b]/intro [c]link [d]/account [e]/projects</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>